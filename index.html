<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fastest Route Finder</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f4f6fa;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    body {
      min-height: 100vh;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .page-wrapper {
      display: flex;
      flex-direction: row;
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      overflow: hidden;
    }
    .left-panel {
      width: 600px;
      min-width: 320px;
      max-width: 700px;
      background: #f8f9fa;
      box-shadow: 2px 0 8px rgba(44,62,80,0.06);
      padding: 0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      height: 100vh;
    }
    .container {
      max-width: 100%;
      margin: 0;
      background: #fff;
      border-radius: 0 0 12px 0;
      box-shadow: none;
      padding: 36px 32px 28px 32px;
      flex: 1 0 auto;
    }
    h1 {
      text-align: center;
      color: #2d3a4a;
      margin-bottom: 28px;
      font-size: 2rem;
      letter-spacing: 1px;
    }
    label {
      display: block;
      margin-top: 18px;
      color: #34495e;
      font-weight: 500;
      font-size: 1.05rem;
    }
    textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 1rem;
      margin-top: 8px;
      resize: vertical;
      background: #f9fafb;
      transition: border 0.2s;
    }
    textarea:focus {
      border: 1.5px solid #4f8cff;
      outline: none;
      background: #fff;
    }
    .file-upload-label {
      margin-top: 18px;
      color: #34495e;
      font-weight: 500;
      font-size: 1.05rem;
      display: block;
    }
    .file-input {
      margin-top: 8px;
      margin-bottom: 16px;
      width: 100%;
    }
    .address-list-section {
      margin-top: 18px;
      margin-bottom: 18px;
    }
    .address-list-section label {
      font-weight: 400;
      color: #2d3a4a;
      margin-bottom: 6px;
    }
    select, .address-checkbox {
      margin-top: 8px;
      margin-bottom: 8px;
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 1rem;
      background: #f9fafb;
    }
    .address-checkbox {
      width: auto;
      margin-right: 8px;
    }
    button {
      margin-top: 26px;
      padding: 12px 0;
      width: 100%;
      background: linear-gradient(90deg, #4f8cff 0%, #38b6ff 100%);
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(79,140,255,0.08);
      transition: background 0.2s, transform 0.1s;
    }
    button:hover {
      background: linear-gradient(90deg, #38b6ff 0%, #4f8cff 100%);
      transform: translateY(-2px) scale(1.01);
    }
    .divider {
      margin: 24px 0 18px 0;
      border-top: 1px solid #e0e4ea;
    }
    .selected-addresses-section {
      margin: 24px 32px 0 32px;
      flex-shrink: 0;
    }
    .selected-addresses-section label {
      margin-top: 0;
    }
    .right-panel {
      flex: 1 1 0;
      min-width: 0;
      height: 100vh;
      position: relative;
      display: flex;
      flex-direction: column;
      background: #eaf0fa;
    }
    #map {
      width: 100%;
      height: 100vh;
      min-height: 400px;
      border-radius: 0;
      box-shadow: none;
      margin: 0;
    }
    .content-card {
      background: #fff;
      border-radius: 8px;
      padding: 18px 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(44,62,80,0.08);
      border: 1px solid #e0e4ea;
    }
    #filterSection {
        margin-bottom: 18px;
    }
    #filterSection label {
        margin-top: 0;
        margin-right: 10px;
    }
    @media (max-width: 900px) {
      .page-wrapper {
        flex-direction: column;
      }
      .left-panel, .right-panel {
        width: 100vw;
        max-width: 100vw;
        min-width: 0;
        height: auto;
      }
      #map {
        height: 400px;
      }
      .selected-addresses-section {
        margin: 18px 8vw 0 8vw;
      }
    }
    @media (max-width: 600px) {
      .container {
        max-width: 98vw;
        padding: 18px 6vw 18px 6vw;
      }
      h1 {
        font-size: 1.3rem;
      }
      .selected-addresses-section {
        margin: 12px 2vw 0 2vw;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
</head>
<body>
  <div class="page-wrapper">
    <div class="left-panel">
      <div class="container">
        <h1>Fastest Route Finder</h1>
        <form id="routeForm">
          <label class="file-upload-label">
            Upload Excel/CSV file with addresses:
            <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls,.csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,text/csv" />
          </label>
          <div id="messageArea" style="display:none;margin-bottom:14px;padding:10px 14px;border-radius:6px;font-size:1rem;"></div>
          <div id="debugArea" style="display:none;margin-bottom:14px;padding:10px 14px;border-radius:6px;font-size:0.95rem;background:#fffbe7;color:#7a5d00;border:1.5px solid #ffe082;"></div>
          
          <div id="filterSection" class="content-card" style="display:none;">
            <label for="auctionDateFilter">Filter by Auction Date:</label>
            <select id="auctionDateFilter"></select>
          </div>

          <div id="addressListSection" class="address-list-section" style="display:none;">
            <div id="excelAddressesCard" class="content-card">
              <label for="customStartAddress" style="font-weight:600;">Start Address:</label>
              <input type="text" id="customStartAddress" placeholder="(Optional) Enter custom start address" style="width:100%;margin-bottom:8px;" />
              <select id="startAddress"></select>
              <div id="middleAddresses" style="margin:18px 0 18px 0;">
                <label style="font-weight:600;">Addresses in Route:</label>
                <div style="max-height:420px;overflow-y:auto;border:1px solid #e0e4ea;border-radius:6px;background:#fff;scrollbar-width:thin;scrollbar-color:#4f8cff #f4f6fa;">
                  <ul id="middleAddressesList" style="list-style:none;padding:0;margin:10px 0 0 0;"></ul>
                </div>
                <button type="button" id="copyDrawnSelectionBtn" style="display:none; margin-top: 10px; background-color: #6c757d; color: white; width: auto; padding: 8px 15px; font-size: 0.9rem;">Copy Selected Addresses</button>
              </div>
              <label for="customEndAddress" style="font-weight:600;">End Address:</label>
              <input type="text" id="customEndAddress" placeholder="(Optional) Enter custom end address" style="width:100%;margin-bottom:8px;" />
              <select id="endAddress"></select>
            </div>
          </div>
          <div class="divider"></div>
          <label id="manualEntryLabel">
            Addresses (one per line, in any order):
            <textarea id="addresses" rows="7" cols="50" required></textarea>
          </label>
          <button type="submit">Get Optimized Route</button>
        </form>
      </div>
      <!-- selected-addresses-section removed for redundancy -->
    </div>
    <div class="right-panel">
      <div id="map"></div>
    </div>
  </div>
  <script>
    console.log("Main script started");
    const excelFileInput = document.getElementById('excelFile');
    const messageArea = document.getElementById('messageArea');
    const addressListSection = document.getElementById('addressListSection');
    const debugArea = document.getElementById('debugArea');
    const startAddressSelect = document.getElementById('startAddress');
    const endAddressSelect = document.getElementById('endAddress');
    const middleAddressesList = document.getElementById('middleAddressesList');
    const addressesTextarea = document.getElementById('addresses');
    const manualEntryLabel = document.getElementById('manualEntryLabel');
    const filterSection = document.getElementById('filterSection');
    const auctionDateFilterSelect = document.getElementById('auctionDateFilter');
    const copyBtn = document.getElementById('copyDrawnSelectionBtn');

    let allExcelItems = []; // Holds all successfully parsed items from Excel
    let currentlyDisplayedItems = []; // Holds items after filtering, used for UI population

    function formatDate(rawDateValue) {
      if (rawDateValue === null || rawDateValue === undefined || String(rawDateValue).trim() === "") return null;
      let date;
      if (typeof rawDateValue === 'number') {
        const excelEpoch = new Date(1899, 11, 30);
        date = new Date(excelEpoch.getTime() + rawDateValue * 24 * 60 * 60 * 1000);
        if (rawDateValue < 60) date.setDate(date.getDate() - 1);
      } else if (rawDateValue instanceof Date) {
        date = rawDateValue;
      } else if (typeof rawDateValue === 'string') {
        date = new Date(rawDateValue);
        if (isNaN(date.getTime())) {
          const parts = rawDateValue.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
          if (parts) {
            let year = parseInt(parts[3], 10);
            if (year < 100) year += (year < 50 ? 2000 : 1900);
            let d1 = new Date(year, parseInt(parts[1], 10) - 1, parseInt(parts[2], 10));
            let d2 = new Date(year, parseInt(parts[2], 10) - 1, parseInt(parts[1], 10));
            if (!isNaN(d1.getTime()) && d1.getMonth() === (parseInt(parts[1], 10) - 1)) date = d1;
            else if (!isNaN(d2.getTime()) && d2.getMonth() === (parseInt(parts[2], 10) - 1)) date = d2;
            else date = null;
          } else date = null;
        }
      }
      if (date && !isNaN(date.getTime())) {
        return `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}/${date.getFullYear()}`;
      }
      return typeof rawDateValue === 'string' ? rawDateValue : null;
    }

function showMessage(msg, type = "info") {
  const messageArea = document.getElementById('messageArea');
  if (!messageArea) return;
  messageArea.innerHTML = msg;
  messageArea.style.display = 'block';
  messageArea.style.background = type === 'success'
    ? '#e6f9ec'
    : type === 'error'
    ? '#ffeaea'
    : type === 'warning'
    ? '#fffbe7'
    : '#eaf1fb';
  messageArea.style.color = type === 'success'
    ? '#217a3c'
    : type === 'error'
    ? '#b30000'
    : type === 'warning'
    ? '#7a5d00'
    : '#1a355b';
  messageArea.style.border = type === 'success'
    ? '1.5px solid #6ee7b7'
    : type === 'error'
    ? '1.5px solid #ffb3b3'
    : type === 'warning'
    ? '1.5px solid #ffe082'
    : '1.5px solid #b3c6e6';
}
function hideMessage() { /* ... (implementation unchanged) ... */ }
    function showDebug(headers, rows) { /* ... (implementation unchanged) ... */ }
    function hideDebug() { /* ... (implementation unchanged) ... */ }

    excelFileInput.addEventListener('change', function (e) {
      console.log('File input CHANGED');
      hideMessage(); hideDebug();
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = function (evt) {
        console.log('File reader ONLOAD');
        try {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: "array", cellDates: true }); // cellDates:true helps with date parsing
          if (!workbook.SheetNames || workbook.SheetNames.length === 0) { showMessage('No sheets found.', 'error'); return; }
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, dateNF: 'MM/DD/YYYY' }); // raw:false, dateNF for better date strings
          
          if (!rows.length) { showMessage('No data in sheet.', 'error'); return; }
          let firstDataRow = 0;
          while (firstDataRow < rows.length && rows[firstDataRow].every(cell => !cell || String(cell).trim() === "")) firstDataRow++;
          if (firstDataRow >= rows.length) { showMessage('No header row.', 'error'); return; }
          
          const headers = rows[firstDataRow].map(h => String(h || "EmptyHeader").trim());
          const dataRows = rows.slice(firstDataRow + 1).filter(row => row.some(cell => cell && String(cell).trim() !== ""));

          let addressFieldPrompt = document.getElementById('addressFieldPrompt');
          if (!addressFieldPrompt) {
            addressFieldPrompt = document.createElement('div');
            addressFieldPrompt.id = 'addressFieldPrompt';
            addressFieldPrompt.style = 'margin:16px 0;padding:12px;background:#fffbe7;border:1.5px solid #ffe082;border-radius:8px;';
            // Ensure it's visible when created or re-created
            addressFieldPrompt.style.display = 'block'; 
            filterSection.parentNode.insertBefore(addressFieldPrompt, filterSection); 
            console.log('addressFieldPrompt created and inserted.');
          } else {
            addressFieldPrompt.style.display = 'block'; // Ensure it's visible if it already exists
            console.log('addressFieldPrompt already exists, ensuring it is visible.');
          }
          
          let preset = null; try { preset = JSON.parse(localStorage.getItem('addressColPreset') || 'null'); } catch {}
          console.log('Setting addressFieldPrompt.innerHTML');
          addressFieldPrompt.innerHTML = `
            <b>Select columns:</b><br>
            <label>Address: <select id="addressColSelect">${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <label>City (opt): <select id="cityColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <label>State (opt): <select id="stateColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label><br>
            <label>First Name (opt): <select id="firstNameColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <label>Last Name (opt): <select id="lastNameColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label><br>
            <label>Auction Date (opt): <select id="auctionDateColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <button type="button" id="confirmAddressCols">Confirm</button> <button type="button" id="clearPreset">Clear Preset</button>
          `;

          if (preset && Array.isArray(preset) && preset.length === 6) { // Now 6 values
            document.getElementById('addressColSelect').value = preset[0];
            if(preset[1] !== null) document.getElementById('cityColSelect').value = preset[1];
            if(preset[2] !== null) document.getElementById('stateColSelect').value = preset[2];
            if(preset[3] !== null) document.getElementById('firstNameColSelect').value = preset[3];
            if(preset[4] !== null) document.getElementById('lastNameColSelect').value = preset[4];
            if(preset[5] !== null) document.getElementById('auctionDateColSelect').value = preset[5];
          }

          document.getElementById('confirmAddressCols').onclick = function() {
            try {
              console.log("CONFIRM BUTTON CLICKED - HANDLER STARTED");
              const addrIdx = parseInt(document.getElementById('addressColSelect').value, 10);
              const cityIdx = document.getElementById('cityColSelect').value !== "" ? parseInt(document.getElementById('cityColSelect').value, 10) : null;
              const stateIdx = document.getElementById('stateColSelect').value !== "" ? parseInt(document.getElementById('stateColSelect').value, 10) : null;
              const firstNameIdx = document.getElementById('firstNameColSelect').value !== "" ? parseInt(document.getElementById('firstNameColSelect').value, 10) : null;
              const lastNameIdx = document.getElementById('lastNameColSelect').value !== "" ? parseInt(document.getElementById('lastNameColSelect').value, 10) : null;
              const auctionDateIdx = document.getElementById('auctionDateColSelect').value !== "" ? parseInt(document.getElementById('auctionDateColSelect').value, 10) : null;

              localStorage.setItem('addressColPreset', JSON.stringify([addrIdx, cityIdx, stateIdx, firstNameIdx, lastNameIdx, auctionDateIdx]));

              console.log('[DEBUG] dataRows.length:', dataRows.length);
              const filteredRows = dataRows.filter(row => row[addrIdx] && String(row[addrIdx]).trim() !== "");
              console.log('[DEBUG] After first filter, filteredRows.length:', filteredRows.length);
              const mappedItems = filteredRows.map(row => {
                let fullAddress = String(row[addrIdx] || "").trim();
                if (cityIdx !== null && row[cityIdx]) fullAddress += ', ' + String(row[cityIdx]).trim();
                if (stateIdx !== null && row[stateIdx]) fullAddress += ', ' + String(row[stateIdx]).trim();
                
                let fullName = null;
                const firstName = firstNameIdx !== null && row[firstNameIdx] ? String(row[firstNameIdx]).trim() : null;
                const lastName = lastNameIdx !== null && row[lastNameIdx] ? String(row[lastNameIdx]).trim() : null;
                if (firstName && lastName) fullName = `${firstName} ${lastName}`;
                else if (firstName) fullName = firstName;
                else if (lastName) fullName = lastName;

                const rawDate = auctionDateIdx !== null && row[auctionDateIdx] ? row[auctionDateIdx] : null;
                return {
                  address: fullAddress, name: fullName,
                  auctionDateRaw: rawDate, auctionDateFormatted: formatDate(rawDate),
                  lat: null, lng: null
                };
              });
              console.log('[DEBUG] After map, mappedItems.length:', mappedItems.length);
              allExcelItems = mappedItems.filter(item => item.address.length > 0);
              console.log('[DEBUG] After second filter, allExcelItems.length:', allExcelItems.length);

              currentlyDisplayedItems = [...allExcelItems]; // Initially display all

              if (currentlyDisplayedItems.length < 1) { 
                showMessage('No valid addresses found.', 'error'); return;
              }
              
              setTimeout(function() {
                console.log('[DEBUG] Inside setTimeout for UI display');
                hideDebug();
                populateAuctionDateFilter(currentlyDisplayedItems);
                filterSection.style.display = '';
                console.log('[DEBUG] filterSection.style.display set to blank. Computed:', getComputedStyle(filterSection).display, 'offsetHeight:', filterSection.offsetHeight);
                populateAddressSelection(currentlyDisplayedItems);
                addressListSection.style.display = '';
                console.log('[DEBUG] addressListSection.style.display set to blank. Computed:', getComputedStyle(addressListSection).display, 'offsetHeight:', addressListSection.offsetHeight);
                addressesTextarea.required = false; 
                manualEntryLabel.style.display = 'none';
                showMessage('Addresses loaded.', 'success');
                console.log('Confirm button clicked. Hiding addressFieldPrompt (from timeout).');
                addressFieldPrompt.style.display = 'none'; 

                if (currentlyDisplayedItems.length > 0) {
                  showMessage('Geocoding addresses...', 'info');
                  geocodeAddresses(currentlyDisplayedItems)
                    .then(geocodedItems => {
                      allExcelItems = geocodedItems; // Update allExcelItems with geocoded data
                      currentlyDisplayedItems = [...allExcelItems]; // Reset displayed to all (geocoded)
                      applyAuctionDateFilter(); // Re-apply filter if any, then update UI
                    })
                    .catch(err => showMessage('Geocoding error: ' + err, 'error'));
                }
              }, 0);
            } catch (err) { showMessage('Error processing columns: ' + err, 'error'); }
          };
          document.getElementById('clearPreset').onclick = () => { localStorage.removeItem('addressColPreset'); showMessage('Preset cleared.', 'info'); };
          // EXIT after setting up prompt and handlers so rest of function doesn't run
          return;
        } catch (err) { showMessage('Error parsing file: ' + err, 'error'); }
      };
      reader.readAsArrayBuffer(file);
    });

    function populateAuctionDateFilter(items) {
        const dates = new Set();
        items.forEach(item => {
            if (item.auctionDateFormatted) dates.add(item.auctionDateFormatted);
        });
        auctionDateFilterSelect.innerHTML = '<option value="all">All Dates</option>';
        Array.from(dates).sort((a,b) => new Date(a) - new Date(b)).forEach(date => {
            auctionDateFilterSelect.innerHTML += `<option value="${date}">${date}</option>`;
        });
    }

    auctionDateFilterSelect.addEventListener('change', applyAuctionDateFilter);

    function applyAuctionDateFilter() {
        const selectedDate = auctionDateFilterSelect.value;
        if (selectedDate === "all") {
            currentlyDisplayedItems = [...allExcelItems];
        } else {
            currentlyDisplayedItems = allExcelItems.filter(item => item.auctionDateFormatted === selectedDate);
        }
        populateAddressSelection(currentlyDisplayedItems);
        // updateMiddleAddresses is called by populateAddressSelection
        displayAddressMarkers(currentlyDisplayedItems);
    }
    
    function populateAddressSelection(itemsToDisplay) {
      console.log('[DEBUG] populateAddressSelection called. itemsToDisplay.length:', itemsToDisplay.length);
      startAddressSelect.innerHTML = '';
      endAddressSelect.innerHTML = '';
      
      const ph1 = document.createElement('option'); ph1.value = ''; ph1.textContent = '-- Select Start --'; startAddressSelect.appendChild(ph1);
      const ph2 = document.createElement('option'); ph2.value = ''; ph2.textContent = '-- Select End --'; endAddressSelect.appendChild(ph2);

      itemsToDisplay.forEach((item) => {
        let dText = item.address;
        if (item.name) dText = `${item.name} - ${dText}`;
        if (item.auctionDateFormatted) dText += ` (Auction: ${item.auctionDateFormatted})`;
        const opt = document.createElement('option'); opt.value = item.address; opt.textContent = dText;
        startAddressSelect.appendChild(opt.cloneNode(true));
        endAddressSelect.appendChild(opt);
      });
      updateMiddleAddresses(); // Uses currentlyDisplayedItems implicitly if not passed
      startAddressSelect.onchange = updateMiddleAddresses;
      endAddressSelect.onchange = updateMiddleAddresses;
      console.log('[DEBUG] populateAddressSelection finished. startAddressSelect.options:', startAddressSelect.options.length, 'endAddressSelect.options:', endAddressSelect.options.length);
    }

    function updateMiddleAddresses() { // Operates on currentlyDisplayedItems
      const startAddr = startAddressSelect.value;
      const endAddr = endAddressSelect.value;
      middleAddressesList.innerHTML = '';

      currentlyDisplayedItems.forEach(item => {
        if (item.address !== startAddr && item.address !== endAddr) {
          const li = document.createElement('li');
          const cb = document.createElement('input'); cb.type = 'checkbox'; cb.className = 'address-checkbox'; cb.value = item.address; cb.checked = false;
          li.appendChild(cb);
          let dText = item.address;
          if (item.name) dText = `<b>${item.name}</b> - ${dText}`;
          if (item.auctionDateFormatted) dText += ` <span style="color:#0077b6;">(Auction: ${item.auctionDateFormatted})</span>`;
          const span = document.createElement('span'); span.innerHTML = ' ' + dText;
          li.appendChild(span);
          middleAddressesList.appendChild(li);
        }
      });
    }
    document.getElementById('routeForm').onsubmit = async function(e) {
  console.log('ROUTE FORM SUBMITTED');
  e.preventDefault();
  showMessage('Optimizing route...', 'info');

  let addresses = [];
  const startAddr = document.getElementById('customStartAddress').value.trim() || document.getElementById('startAddress').value;
  let endAddr = document.getElementById('customEndAddress').value.trim() || document.getElementById('endAddress').value;

  const middleCheckboxes = document.querySelectorAll('#middleAddressesList input[type="checkbox"]:checked');
  const middleAddrs = Array.from(middleCheckboxes).map(cb => cb.value);

  if (startAddr) {
    addresses.push(startAddr);
    addresses = addresses.concat(middleAddrs);

    if (endAddr && endAddr !== startAddr) {
      addresses.push(endAddr);
    } else if (!endAddr && startAddr) {
      addresses.push(startAddr); // Use start as end for round trip
      console.log("No end address provided, using start address as end for a round trip.");
    }
  }

  // Fallback to textarea if no addresses from selections
  if (addresses.length < 2 && addressesTextarea.value.trim() !== "") {
    addresses = addressesTextarea.value.trim().split('\n').map(a => a.trim()).filter(a => a);
  }

  if (addresses.length < 2) {
    showMessage('Please select or enter at least two addresses.', 'error');
    return;
  }

  try {
    const response = await fetch('https://googlemaps-fastest-route-1.onrender.com/optimize-route', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ addresses: addresses }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error', details: response.statusText }));
      throw new Error(`HTTP error ${response.status}: ${errorData.error} - ${JSON.stringify(errorData.details)}`);
    }

    const result = await response.json();
    console.log('Backend response received:', result);
    console.log('Original addresses sent to backend:', addresses);
    const waypoints = addresses.slice(1, -1);
    console.log('Waypoints extracted:', waypoints);
    console.log('Order from backend (result.order):', result.order);

    let optimizedFullRoute = [addresses[0]];
    if (result.order && Array.isArray(result.order)) {
      result.order.forEach(idx => {
        console.log('Processing waypoint index from backend:', idx, 'Corresponding waypoint:', waypoints[idx]);
        optimizedFullRoute.push(waypoints[idx]);
      });
      optimizedFullRoute.push(addresses[addresses.length - 1]);
      console.log('Constructed optimizedFullRoute:', optimizedFullRoute);
      // Build Google Maps directions URL and open in new tab
      if (optimizedFullRoute.length >= 2) {
        const origin = encodeURIComponent(optimizedFullRoute[0]);
        const destination = encodeURIComponent(optimizedFullRoute[optimizedFullRoute.length - 1]);
        let waypointsString = "";
        if (optimizedFullRoute.length > 2) {
          waypointsString = optimizedFullRoute.slice(1, -1).map(addr => encodeURIComponent(addr)).join('|');
        }
        let googleMapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}`;
        if (waypointsString) {
          googleMapsUrl += `&waypoints=${waypointsString}`;
        }
        googleMapsUrl += `&travelmode=driving`;
        window.open(googleMapsUrl, '_blank');
        showMessage('Optimized route opened in Google Maps.<br>Order:<br>' + optimizedFullRoute.join('<br>'), 'success');
      } else {
        showMessage('Not enough addresses to generate a Google Maps link.', 'error');
      }
    } else {
      console.error('Error: result.order is not a valid array!', result.order);
      showMessage('Error processing backend response: Invalid route order.', 'error');
    }
    // Optionally, update the map here to show the optimized route.
  } catch (error) {
    console.error('Optimization error:', error);
    showMessage('Failed to optimize route: ' + error.message, 'error');
  }
};
    excelFileInput.addEventListener('click', function(e) { /* ... (implementation as before, reset allExcelItems and currentlyDisplayedItems) ... */ });
    
    // ... (rest of the script: initializeBasicMap, geocodeAddresses, displayAddressMarkers, Leaflet draw events) ...
    // Ensure geocodeAddresses and displayAddressMarkers use the passed items (currentlyDisplayedItems)
    // Ensure Leaflet draw event CREATED uses currentlyDisplayedItems for checking markers
    // Ensure populateAddressSelection, updateMiddleAddresses use the correct item list (currentlyDisplayedItems)

    // Re-pasting the functions that need to be aware of currentlyDisplayedItems or allExcelItems
    // (Many were already correct or handled by passing the list as an argument)

    function populateAddressSelection(itemsToDisplay) {
      console.log('[DEBUG] populateAddressSelection called. itemsToDisplay.length:', itemsToDisplay.length);
      startAddressSelect.innerHTML = '';
      endAddressSelect.innerHTML = '';
      
      const ph1 = document.createElement('option'); ph1.value = ''; ph1.textContent = '-- Select Start --'; startAddressSelect.appendChild(ph1);
      const ph2 = document.createElement('option'); ph2.value = ''; ph2.textContent = '-- Select End --'; endAddressSelect.appendChild(ph2);

      itemsToDisplay.forEach((item) => {
        let dText = item.address;
        if (item.name) dText = `${item.name} - ${dText}`;
        if (item.auctionDateFormatted) dText += ` (Auction: ${item.auctionDateFormatted})`;
        const opt = document.createElement('option'); opt.value = item.address; opt.textContent = dText;
        startAddressSelect.appendChild(opt.cloneNode(true));
        endAddressSelect.appendChild(opt);
      });
      updateMiddleAddresses(); // Uses currentlyDisplayedItems implicitly if not passed
      startAddressSelect.onchange = updateMiddleAddresses;
      endAddressSelect.onchange = updateMiddleAddresses;
      console.log('[DEBUG] populateAddressSelection finished. startAddressSelect.options:', startAddressSelect.options.length, 'endAddressSelect.options:', endAddressSelect.options.length);
    }

    function updateMiddleAddresses() { // Operates on currentlyDisplayedItems
      const startAddr = startAddressSelect.value;
      const endAddr = endAddressSelect.value;
      middleAddressesList.innerHTML = '';

      currentlyDisplayedItems.forEach(item => {
        if (item.address !== startAddr && item.address !== endAddr) {
          const li = document.createElement('li');
          const cb = document.createElement('input'); cb.type = 'checkbox'; cb.className = 'address-checkbox'; cb.value = item.address; cb.checked = false;
          li.appendChild(cb);
          let dText = item.address;
          if (item.name) dText = `<b>${item.name}</b> - ${dText}`;
          if (item.auctionDateFormatted) dText += ` <span style="color:#0077b6;">(Auction: ${item.auctionDateFormatted})</span>`;
          const span = document.createElement('span'); span.innerHTML = ' ' + dText;
          li.appendChild(span);
          middleAddressesList.appendChild(li);
        }
      });
    }
    
    // Ensure excelFileInput click resets all relevant lists
    excelFileInput.addEventListener('click', function(e) {
      console.log(`File input CLICKED (${new Date().toISOString()}) - resetting UI and data.`);
      allExcelItems = [];
      currentlyDisplayedItems = [];
      excelAddresses = []; 
      addressListSection.style.display = 'none';
      filterSection.style.display = 'none';
      auctionDateFilterSelect.innerHTML = '';
      manualEntryLabel.style.display = '';
      addressesTextarea.required = true;
      hideMessage();
      hideDebug();
      // let prompt = document.getElementById('addressFieldPrompt');
      // if(prompt) {
      //   prompt.innerHTML = ''; // Clear content first
      //   prompt.style.display = 'block'; // Explicitly show it. This might be what was missing or overridden.
      //   console.log('addressFieldPrompt reset and made visible on file input click.');
      // }
    });


    // MAP AND DRAWING LOGIC (ensure it uses currentlyDisplayedItems for context if needed)
    let map;
    let drawnItems;
    function initializeBasicMap() {
      console.log("initializeBasicMap: Starting");
      try {
        map = L.map('map').setView([29.7604, -95.3698], 10);
        console.log("initializeBasicMap: L.map created");

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        console.log("initializeBasicMap: TileLayer added");

        drawnItems = new L.FeatureGroup();
        console.log("initializeBasicMap: FeatureGroup created");
        map.addLayer(drawnItems);
        console.log("initializeBasicMap: FeatureGroup added to map");

        const drawControl = new L.Control.Draw({
          edit: { featureGroup: drawnItems },
          draw: {
            polygon: true,
            polyline: false,
            rectangle: true,
            circle: true,
            marker: false,
            circlemarker: false
          }
        });
        console.log("initializeBasicMap: DrawControl options defined");
        map.addControl(drawControl);
        console.log("initializeBasicMap: DrawControl added to map");
      } catch (error) {
        console.error("initializeBasicMap: ERROR during initialization!", error);
      }
      console.log("initializeBasicMap: Finished (or error caught)");
    }
    console.log("About to initialize map...");
    initializeBasicMap();

    async function geocodeAddresses(itemsArray) { /* ... (as previously corrected, operates on itemsArray) ... */ 
        const apiKey = "AIzaSyAq-_o7JolKDWy943Q-dejkoqzPvJKIV2k"; 
        const cache = JSON.parse(localStorage.getItem("geocodeCache") || "{}");
        for (const item of itemsArray) {
            if (typeof item.lat === 'number' && typeof item.lng === 'number' && item.lat !== null && item.lng !== null) continue;
            const addressToGeocode = item.address;
            if (cache[addressToGeocode]) {
                item.lat = cache[addressToGeocode].lat; item.lng = cache[addressToGeocode].lng; continue;
            }
            const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(addressToGeocode)}&key=${apiKey}`;
            try {
                const resp = await fetch(url); const data = await resp.json();
                if (data.status === "OK" && data.results && data.results[0]) {
                    const loc = data.results[0].geometry.location;
                    item.lat = loc.lat; item.lng = loc.lng;
                    cache[addressToGeocode] = { lat: loc.lat, lng: loc.lng };
                } else { item.lat = null; item.lng = null; console.warn('Failed geocode:', addressToGeocode, data.status); }
            } catch (err) { item.lat = null; item.lng = null; console.error('Fetch error geocoding:', addressToGeocode, err); }
            await new Promise(res => setTimeout(res, 60));
        }
        localStorage.setItem("geocodeCache", JSON.stringify(cache));
        return itemsArray; 
    }

    let addressMarkersLayer = null;
    function displayAddressMarkers(itemsToDisplayOnMap) { /* ... (as previously corrected, uses itemsToDisplayOnMap) ... */
        if (!map) return;
        if (addressMarkersLayer) map.removeLayer(addressMarkersLayer);
        const markers = []; let plottedCount = 0;
        itemsToDisplayOnMap.forEach(item => {
            if (item && typeof item.lat === 'number' && typeof item.lng === 'number') {
                const marker = L.marker([item.lat, item.lng]);
                let popupHtml = `<strong>${item.address}</strong>`;
                if (item.name) popupHtml = `<strong>${item.name}</strong><br>${item.address}`;
                if (item.auctionDateFormatted) popupHtml += `<br><span style="color:#0077b6;">Auction: ${item.auctionDateFormatted}</span>`;
                marker.bindPopup(popupHtml);
                marker.customData = item; 
                markers.push(marker); plottedCount++;
            }
        });
        if (plottedCount > 0) {
            addressMarkersLayer = L.layerGroup(markers).addTo(map);
            const notPlotted = itemsToDisplayOnMap.length - plottedCount;
            showMessage(`${plottedCount} plotted. ${notPlotted > 0 ? notPlotted + ' not geocoded.' : ''}`, notPlotted > 0 ? 'warning' : 'success');
        } else showMessage('No coordinates to plot.', 'warning');
    }

    if (window.L && map) {
      // --- Custom Clear All Button Control ---
      L.Control.ClearButton = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
          container.innerHTML = '<button id="clearAllMapSelections" title="Clear Drawn Shapes & Selections" style="padding:4px 10px;font-size:1rem;cursor:pointer;">Clear All</button>';
          container.style.backgroundColor = 'white';
          container.style.padding = '5px';
          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);
          container.onclick = function() {
            handleClearSelections();
            showMessage('Selections and drawn shapes cleared.', 'info');
          };
          return container;
        },
        onRemove: function(map) {}
      });
      L.control.clearButton = function(opts) {
        return new L.Control.ClearButton(opts);
      };
      L.control.clearButton({ position: 'topright' }).addTo(map);

      // --- Centralized clear logic ---
      function handleClearSelections() {
        if (drawnItems) {
          drawnItems.clearLayers();
        }
        if (copyBtn) copyBtn.style.display = 'none';
        populateAddressSelection(currentlyDisplayedItems);
        console.log("handleClearSelections: Selections cleared and address list repopulated.");
      }

      map.on(L.Draw.Event.CREATED, function (event) {
        const drawnLayer = event.layer;
        drawnItems.clearLayers(); 
        drawnItems.addLayer(drawnLayer);
        
        const selectedItemsInShape = []; 

        if (addressMarkersLayer) {
          addressMarkersLayer.eachLayer(function (marker) {
            if (marker.customData) {
                const markerLatLng = marker.getLatLng();
                let isInside = false;
                if (drawnLayer instanceof L.Circle) isInside = markerLatLng.distanceTo(drawnLayer.getLatLng()) <= drawnLayer.getRadius();
                else if (drawnLayer.getBounds) isInside = drawnLayer.getBounds().contains(markerLatLng);

                if (isInside) {
                    selectedItemsInShape.push(marker.customData);
                }
            }
          });
        }
        
        const middleAddressesListUI = document.getElementById('middleAddressesList');
        if (middleAddressesListUI) {
          middleAddressesListUI.innerHTML = ''; 
          selectedItemsInShape.forEach(item => {
            const li = document.createElement('li');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.className = 'address-checkbox';
            checkbox.value = item.address; checkbox.checked = true; 
            li.appendChild(checkbox);
            let dText = item.address;
            if (item.name) dText = `<b>${item.name}</b> - ${dText}`;
            if (item.auctionDateFormatted) dText += ` <span style="color:#0077b6;">(Auction: ${item.auctionDateFormatted})</span>`;
            const span = document.createElement('span'); span.innerHTML = ' ' + dText;
            li.appendChild(span);
            middleAddressesListUI.appendChild(li);
          });
        }
        if (copyBtn) copyBtn.style.display = selectedItemsInShape.length > 0 ? 'block' : 'none';
        if (selectedItemsInShape.length > 0) {
          showMessage(`${selectedItemsInShape.length} addresses selected.`, 'success');
        }
      });

      map.on('draw:deleted', function() {
        handleClearSelections();
        showMessage('Drawn shapes deleted and selections cleared.', 'info');
      });

      // Copy Selected Addresses button logic
      if (copyBtn) {
        copyBtn.addEventListener('click', function() {
          const addressesToCopy = [];
          const listItems = middleAddressesList.getElementsByTagName('li');
          for (let item of listItems) {
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (checkbox && checkbox.checked) {
              addressesToCopy.push(checkbox.value);
            }
          }
          if (addressesToCopy.length > 0) {
            navigator.clipboard.writeText(addressesToCopy.join('\n'))
              .then(() => showMessage('Selected addresses copied to clipboard!', 'success'))
              .catch(err => showMessage('Failed to copy addresses: ' + err, 'error'));
          } else {
            showMessage('No addresses to copy.', 'info');
          }
        });
      }
    }
  </script>
</body>
</html>
