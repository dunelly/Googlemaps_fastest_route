<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Smash Routes</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f7f9fb;
      font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
    }
    body {
      min-height: 100vh;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .page-wrapper {
      display: flex;
      flex-direction: row;
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      overflow: hidden;
    }
    .left-panel {
      width: 600px;
      min-width: 320px;
      max-width: 700px;
      background: #f8f9fa;
      box-shadow: 2px 0 8px rgba(44,62,80,0.06);
      padding: 0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      height: 100vh;
    }
    .container {
      max-width: 100%;
      margin: 0;
      background: #fff;
      border-radius: 0 0 16px 0;
      box-shadow: 0 2px 16px rgba(44,62,80,0.06);
      padding: 40px 36px 32px 36px;
      flex: 1 0 auto;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    h1 {
      text-align: center;
      color: #1a2330;
      margin-bottom: 32px;
      font-size: 2.8rem;
      font-weight: 800;
      letter-spacing: 1px;
      font-family: 'Montserrat', 'Inter', 'Segoe UI', Arial, sans-serif;
    }
    label {
      display: block;
      margin-top: 18px;
      color: #34495e;
      font-weight: 500;
      font-size: 1.05rem;
    }
    .card {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 2px 16px rgba(44,62,80,0.10);
      padding: 28px 24px 22px 24px;
      margin-bottom: 18px;
      border: 1.5px solid #e6eaf2;
      display: flex;
      flex-direction: column;
      gap: 18px;
      transition: box-shadow 0.18s;
    }
    .card:hover, .card:focus-within {
      box-shadow: 0 6px 32px rgba(44,62,80,0.13);
      border-color: #b3c6e6;
    }
    .card-header {
      font-size: 1.18rem;
      font-weight: 700;
      color: #1a2330;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 0.5em;
    }
    .card-section {
      margin-bottom: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    textarea, input[type="text"], select {
      width: 100%;
      padding: 12px 14px;
      border: 1.5px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      margin-top: 8px;
      margin-bottom: 8px;
      resize: vertical;
      background: #f9fafb;
      transition: border 0.2s, box-shadow 0.2s;
      font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
      box-sizing: border-box;
    }
    textarea:focus, input[type="text"]:focus, select:focus {
      border: 1.5px solid #4f8cff;
      outline: none;
      background: #fff;
      box-shadow: 0 0 0 2px #e3f0ff;
    }
    .file-upload-label {
      margin-top: 18px;
      color: #34495e;
      font-weight: 500;
      font-size: 1.05rem;
      display: block;
    }
    .file-input {
      margin-top: 8px;
      margin-bottom: 16px;
      width: 100%;
    }
    .address-list-section {
      margin-top: 18px;
      margin-bottom: 18px;
    }
    .address-list-section label {
      font-weight: 400;
      color: #2d3a4a;
      margin-bottom: 6px;
    }
    select, .address-checkbox {
      margin-top: 8px;
      margin-bottom: 8px;
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 1rem;
      background: #f9fafb;
    }
    .address-checkbox {
      width: auto;
      margin-right: 8px;
    }
    button {
      margin-top: 24px;
      padding: 13px 0;
      width: 100%;
      background: #1a355b;
      color: #fff;
      border: none;
      border-radius: 7px;
      font-size: 1.15rem;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(44,62,80,0.10);
      transition: background 0.18s, transform 0.1s, box-shadow 0.18s;
      font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
      letter-spacing: 0.01em;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.6em;
      user-select: none;
    }
    button:hover, button:focus {
      background: #254075;
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 4px 16px rgba(44,62,80,0.13);
    }
    .add-address-btn {
      background: #217a3c;
      color: #fff;
      font-weight: 700;
      font-size: 1.07rem;
      border-radius: 7px;
      box-shadow: 0 2px 8px rgba(33,122,60,0.09);
      margin-top: 0;
      margin-bottom: 8px;
      padding: 10px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5em;
      transition: background 0.18s, box-shadow 0.18s;
    }
    .add-address-btn:hover, .add-address-btn:focus {
      background: #17632e;
      box-shadow: 0 4px 14px rgba(33,122,60,0.13);
    }
    .add-address-btn svg {
      width: 1.2em;
      height: 1.2em;
      vertical-align: middle;
      margin-right: 0.2em;
      fill: #fff;
      display: inline-block;
    }
    /* Small red X for remove button in single entry */
    .remove-address-btn {
      color: #e53935 !important;
      background: none !important;
      border: none !important;
      font-size: 1.1em !important;
      width: 22px !important;
      height: 22px !important;
      min-width: 0 !important;
      min-height: 0 !important;
      padding: 0 !important;
      line-height: 22px !important;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .remove-address-btn:hover {
      background: #ffeaea !important;
    }
    .optimize-btn svg {
      width: 1.2em;
      height: 1.2em;
      vertical-align: middle;
      margin-right: 0.2em;
      fill: #fff;
      display: inline-block;
    }
    .secondary-btn {
      background: #f4f6fa;
      color: #4f8cff;
      border: 1.5px solid #b3c6e6;
      box-shadow: none;
      margin-top: 10px;
      margin-bottom: 0;
    }
    .secondary-btn:hover {
      background: #eaf1fb;
      color: #217a3c;
      border-color: #4f8cff;
    }
    .divider {
      margin: 24px 0 18px 0;
      border-top: 1px solid #e0e4ea;
    }
    .selected-addresses-section {
      margin: 24px 32px 0 32px;
      flex-shrink: 0;
    }
    .selected-addresses-section label {
      margin-top: 0;
    }
    .right-panel {
      flex: 1 1 0;
      min-width: 0;
      height: 100vh;
      position: relative;
      display: flex;
      flex-direction: column;
      background: #eaf0fa;
    }
    #map {
      width: 100%;
      height: 100vh;
      min-height: 400px;
      border-radius: 0;
      box-shadow: none;
      margin: 0;
    }
    .content-card {
      background: #fff;
      border-radius: 12px;
      padding: 22px 22px 18px 22px;
      margin-bottom: 22px;
      box-shadow: 0 2px 12px rgba(44,62,80,0.06);
      border: 1.5px solid #e6eaf2;
    }
    #filterSection {
        margin-bottom: 18px;
    }
    #filterSection label {
        margin-top: 0;
        margin-right: 10px;
    }
    @media (max-width: 900px) {
      .page-wrapper {
        flex-direction: column;
      }
      .left-panel, .right-panel {
        width: 100vw;
        max-width: 100vw;
        min-width: 0;
        height: auto;
      }
      #map {
        height: 400px;
      }
      .selected-addresses-section {
        margin: 18px 8vw 0 8vw;
      }
    }
    @media (max-width: 600px) {
      .container {
        max-width: 98vw;
        padding: 18px 6vw 18px 6vw;
      }
      h1 {
        font-size: 1.3rem;
      }
      .selected-addresses-section {
        margin: 12px 2vw 0 2vw;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <link href="https://fonts.googleapis.com/css?family=Montserrat:700,800&display=swap" rel="stylesheet">
  <style>
    /* Replace rectangle (box) icon with a custom SVG */
    .leaflet-draw-toolbar .leaflet-draw-draw-rectangle {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='26' height='26'%3E%3Crect x='4' y='4' width='18' height='18' rx='3' fill='none' stroke='%23333' stroke-width='2'/%3E%3C/svg%3E") !important;
      background-size: 22px 22px !important;
      background-repeat: no-repeat !important;
      background-position: center !important;
      background-color: #fff !important;
    }
    .leaflet-draw-toolbar .leaflet-draw-draw-rectangle span {
      opacity: 0 !important;
      background: none !important;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <style>
    /* Replace polygon (pentagon) icon with a lasso SVG */
    .leaflet-draw-toolbar .leaflet-draw-draw-polygon {
      background-image: url("data:image/svg+xml,%3Csvg width='26' height='26' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 19 Q4 13 8 8 Q13 2 19 7 Q24 12 18 18 Q13 23 7 19 Z' fill='none' stroke='%23333' stroke-width='2.2'/%3E%3Ccircle cx='7' cy='19' r='2' fill='white' stroke='%23333' stroke-width='1.2'/%3E%3C/svg%3E") !important;
      background-size: 22px 22px !important;
      background-repeat: no-repeat !important;
      background-position: center !important;
      background-color: #fff !important;
    }
    .leaflet-draw-toolbar .leaflet-draw-draw-polygon span {
      opacity: 0 !important;
      background: none !important;
    }
  </style>
  <!-- Firebase App (the core Firebase SDK) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <!-- FirebaseUI for Auth -->
  <link type="text/css" rel="stylesheet" href="https://www.gstatic.com/firebasejs/ui/6.0.2/firebase-ui-auth.css" />
  <script src="https://www.gstatic.com/firebasejs/ui/6.0.2/firebase-ui-auth.js"></script>
  <!-- Firebase config and initialization -->
  <script>
    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDQqCkBqmHRiX04Xtydb2v0IjxpssxzpQQ",
      authDomain: "smash-routes.firebaseapp.com",
      projectId: "smash-routes",
      storageBucket: "smash-routes.appspot.com",
      messagingSenderId: "972794327507",
      appId: "1:972794327507:web:1898851dc74ea32e58ff26",
      measurementId: "G-6LW1NP9XHG"
    };
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
  </script>
</head>
<body>
  <!-- Subtle FirebaseUI Auth Card and Sign In Button -->
  <div id="subtle-login-bar" style="position:fixed;top:18px;right:24px;z-index:10001;">
    <button id="show-login-btn" style="padding:7px 18px;font-size:1rem;background:#4f8cff;color:#fff;border:none;border-radius:7px;box-shadow:0 2px 8px rgba(44,62,80,0.10);font-weight:600;cursor:pointer;display:inline-block;">Sign In</button>
    <div id="user-info" style="display:none;margin-top:0;padding:7px 18px;background:#eaf1fb;border-radius:7px;box-shadow:0 2px 8px rgba(44,62,80,0.10);font-size:1rem;">
      <span id="user-email" style="font-weight:600;"></span>
      <button id="logout-btn" style="margin-left:12px;padding:5px 14px;">Logout</button>
    </div>
  </div>
  <div id="firebaseui-auth-card" style="display:none;position:fixed;top:60px;right:24px;z-index:10002;">
    <div style="width:320px;padding:18px 14px 14px 14px;background:#fff;border-radius:14px;box-shadow:0 6px 32px rgba(44,62,80,0.18);border:1.5px solid #e6eaf2;">
      <div style="text-align:center;margin-bottom:10px;">
        <span style="font-size:1.1rem;font-weight:700;color:#1a2330;">Sign in</span>
      </div>
      <div id="firebaseui-auth-container"></div>
      <button id="close-login-btn" style="margin-top:10px;width:100%;background:#f4f6fa;color:#4f8cff;border:1.5px solid #b3c6e6;border-radius:7px;padding:7px 0;font-size:1rem;font-weight:600;cursor:pointer;">Cancel</button>
    </div>
  </div>
  <div id="user-info" style="display:none;max-width:410px;margin:0 auto 24px auto;padding:16px 24px;background:#eaf1fb;border-radius:12px;">
    <span id="user-email" style="font-weight:600;"></span>
    <button id="logout-btn" style="margin-left:18px;padding:6px 16px;">Logout</button>
  </div>
  <div class="page-wrapper">
    <div class="left-panel">
      <div class="container">
        <h1>Smash Routes</h1>
        <form id="routeForm">
          <div style="margin-bottom:22px;">
            <h2 style="font-size:1.15rem;margin-bottom:12px;">Add Addresses</h2>
            <div id="tabButtonsContainer" style="display: flex; border: 1px solid #d1d5db; border-radius: 8px; overflow: hidden; margin-bottom: 20px;">
              <button type="button" id="singleEntryTab" class="tab-button active" style="flex-grow: 1; padding: 10px 15px; background-color: #fff; border: none; border-right: 1px solid #d1d5db; cursor: pointer; font-size: 0.95rem; color: #007bff; font-weight: 600;">Single Entry</button>
              <button type="button" id="pasteListTab" class="tab-button" style="flex-grow: 1; padding: 10px 15px; background-color: #f8f9fa; border: none; border-right: 1px solid #d1d5db; cursor: pointer; font-size: 0.95rem; color: #495057; font-weight: 500;">Paste List</button>
              <button type="button" id="uploadFileTab" class="tab-button" style="flex-grow: 1; padding: 10px 15px; background-color: #f8f9fa; border: none; cursor: pointer; font-size: 0.95rem; color: #495057; font-weight: 500;">Upload File</button>
            </div>
          </div>

          <!-- Tab Content Sections -->
          <div id="singleEntryContent" class="tab-content" style="display: block;">
            <!-- This is the original manualEntrySection -->
            <label for="manualStartAddress" style="font-weight:600;">Start Address:</label>
            <input type="text" id="manualStartAddress" placeholder="Start address" style="width:100%;margin-bottom:8px;" />
            <div id="manualAddressesList" style="margin-bottom:8px;">
              <!-- Dynamic address fields will be added here by JS -->
            </div>
            <button type="button" id="addManualAddressBtn" class="add-address-btn" style="margin-bottom:8px;">
              <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="9" stroke="white" stroke-width="2" fill="none"/><rect x="9" y="5" width="2" height="10" fill="white"/><rect x="5" y="9" width="10" height="2" fill="white"/></svg>
              Add Destination
            </button>
          </div>

          <div id="pasteListContent" class="tab-content" style="display: none;">
            <label for="pasteAddressesTextarea" style="font-weight:600;">Paste Addresses:</label>
            <textarea id="pasteAddressesTextarea" placeholder="Paste addresses here, one per line" style="width:100%; height:200px; margin-bottom:12px;"></textarea>
            <button type="button" id="confirmPasteBtn" class="add-address-btn" style="background:#4f8cff; width:auto; padding-left:20px; padding-right:20px;">Confirm & Add to Single Entry</button>
          </div>

          <div id="uploadFileContent" class="tab-content" style="display: none;">
            <!-- This is the original Excel/CSV Upload section -->
            <div style="background:#f6faff;border-radius:8px;padding:18px 16px 12px 16px;margin-bottom:18px;">
              <h3 style="font-size:1.08rem;margin-bottom:6px; margin-top:0;">Upload File</h3>
              <label class="file-upload-label" style="margin-top:10px;">
                <span style="font-weight:600;">Excel/CSV file:</span>
                <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls,.csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,text/csv" />
              </label>
              <div style="margin-top:18px;">
                <label for="googleSheetUrl" style="font-weight:600;">Or paste a Google Sheets URL:</label>
                <div style="display:flex;gap:8px;align-items:center;">
                  <input type="text" id="googleSheetUrl" placeholder="https://docs.google.com/spreadsheets/d/..." style="flex:1;"/>
                  <button type="button" id="loadGoogleSheetBtn" style="width:auto;padding:8px 18px;font-size:1rem;background:#1967d2;">Load</button>
                </div>
                <div id="googleSheetError" style="color:#e53935;font-size:0.98em;margin-top:4px;display:none;"></div>
              </div>
              <div id="messageArea" style="display:none;margin-bottom:14px;padding:10px 14px;border-radius:6px;font-size:1rem;"></div>
              <div id="debugArea" style="display:none;margin-bottom:14px;padding:10px 14px;border-radius:6px;font-size:0.95rem;background:#fffbe7;color:#7a5d00;border:1.5px solid #ffe082;"></div>
              <div id="filterSection" class="content-card" style="display:none;">
                <label for="auctionDateMultiSelect">Filter by Auction Date(s):</label>
                <select id="auctionDateMultiSelect" multiple size="6" style="width:100%;min-height:120px;margin-top:8px;margin-bottom:8px;"></select>
                <div style="display:flex;gap:10px;">
                  <button type="button" id="selectAllDatesBtn" style="flex:1;">Select All</button>
                  <button type="button" id="clearDatesBtn" style="flex:1;">Clear Selection</button>
                </div>
              </div>
              <div id="addressListSection" class="address-list-section" style="display:none;">
                <div id="excelAddressesCard" class="content-card">
                  <label for="customStartAddress" style="font-weight:600;display:flex;align-items:center;">
                    Start Address:
                    <span style="background:#ffe082;color:#7a5d00;font-size:0.95rem;font-weight:700;padding:2px 8px;border-radius:6px;margin-left:10px;">Required</span>
                  </label>
                  <input type="text" id="customStartAddress" placeholder="Start address" style="width:100%;margin-bottom:8px;border:2px solid #ffe082;background:#fffde7;" />
                  <div id="middleAddresses" style="margin:18px 0 18px 0;">
                    <label style="font-weight:600;">Addresses from file:</label>
                    <div style="max-height:420px;overflow-y:auto;border:1px solid #e0e4ea;border-radius:6px;background:#fff;scrollbar-width:thin;scrollbar-color:#4f8cff #f4f6fa;">
                      <ul id="middleAddressesList" style="list-style:none;padding:0;margin:10px 0 0 0;"></ul>
                    </div>
                    <button type="button" id="copySelectedBtn" style="display:none; margin-top: 10px; background-color: #6c757d; color: white; width: auto; padding: 8px 15px; font-size: 0.9rem;">Copy</button>
                    <button type="button" id="markVisitedBtn" style="display:none; margin-top: 10px; background-color: #28a745; color: white; width: auto; padding: 8px 15px; font-size: 0.9rem;">Visited</button>
                  </div>
                  <label for="customEndAddress" style="font-weight:600;">End Address (optional):</label>
                  <input type="text" id="customEndAddress" placeholder="End address (optional)" style="width:100%;margin-bottom:8px;" />
                </div>
              </div>
            </div>
          </div>
          <!-- End of Tab Content Sections -->

          <button type="submit" class="optimize-btn" style="margin-top:22px;">
            <svg viewBox="0 0 20 20"><path d="M4 10h12M12 6l4 4-4 4" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
            Get Optimized Route
          </button>
        </form>
      </div>
      <!-- selected-addresses-section removed for redundancy -->
    </div>
    <div class="right-panel">
      <div id="map" style="position:relative;"></div>
      <div id="drawArrowOverlay" style="display:none;position:absolute;z-index:1000;pointer-events:none;"></div>
    </div>
  </div>
  <script>
    console.log("Main script started");

    // Tab switching logic
    const singleEntryTab = document.getElementById('singleEntryTab');
    const pasteListTab = document.getElementById('pasteListTab');
    const uploadFileTab = document.getElementById('uploadFileTab');

    const singleEntryContent = document.getElementById('singleEntryContent');
    const pasteListContent = document.getElementById('pasteListContent');
    const uploadFileContent = document.getElementById('uploadFileContent');
    const pasteAddressesTextarea = document.getElementById('pasteAddressesTextarea');
    const confirmPasteBtn = document.getElementById('confirmPasteBtn');

    const tabButtons = [singleEntryTab, pasteListTab, uploadFileTab];
    const tabContents = [singleEntryContent, pasteListContent, uploadFileContent];

    function setActiveTab(activeIndex) {
      tabButtons.forEach((tab, index) => {
        const isActive = index === activeIndex;
        tab.classList.toggle('active', isActive);
        tab.style.color = isActive ? 'var(--material-primary-color)' : 'var(--material-text-secondary-on-surface)';
        tab.style.borderBottom = isActive ? '2px solid var(--material-primary-color)' : '2px solid transparent';
        // tab.style.backgroundColor = isActive ? 'rgba(var(--material-primary-color-rgb, 25, 118, 210), 0.08)' : 'transparent'; /* Optional subtle background for active tab */
        tabContents[index].style.display = isActive ? 'block' : 'none';
      });
      
      // Ensure addressFieldPrompt is only visible if Upload File tab is active AND no file data is loaded yet.
      // This logic is complex because addressFieldPrompt is created dynamically.
      // A simpler approach is to manage its visibility primarily within the excelFileInput event handler.
      let addressFieldPrompt = document.getElementById('addressFieldPrompt');
      if (addressFieldPrompt) {
          const excelFileHasData = allExcelItems && allExcelItems.length > 0; // Check if data has been processed
          if (activeIndex === 2 && !excelFileHasData) {
              // This logic might need to be inside the excelFile change handler to create the prompt if it doesn't exist
              // For now, assuming it exists and we just control visibility.
              // addressFieldPrompt.style.display = 'block';
          } else {
              addressFieldPrompt.style.display = 'none';
          }
      }
      updateManualAddressRequired();
    }

    singleEntryTab.addEventListener('click', () => setActiveTab(0));
    pasteListTab.addEventListener('click', () => setActiveTab(1));
    uploadFileTab.addEventListener('click', () => {
      setActiveTab(2);
      // Logic to show addressFieldPrompt if no file loaded yet is tricky here,
      // as it's created dynamically. The excelFileInput's 'change' and 'click' handlers
      // are better places to manage its initial visibility or creation.
      // If the file input prompt was hidden, re-show it or trigger logic that shows it
      // This ensures that if a user navigates away and back, the prompt is visible if no file is loaded.
      let addressFieldPrompt = document.getElementById('addressFieldPrompt');
      const excelFileHasValue = excelFileInput && excelFileInput.files && excelFileInput.files.length > 0;
      if (addressFieldPrompt && !excelFileHasValue && !addressListSection.style.display || addressListSection.style.display === 'none') {
         // addressFieldPrompt.style.display = 'block'; // Re-showing it might be too simplistic
         // It might be better to re-trigger part of the excelFileInput's change handler if needed,
         // or ensure the prompt's visibility is correctly managed by the excelFile handler itself.
      }
    });
    
    confirmPasteBtn.addEventListener('click', () => {
      const addressesToPaste = pasteAddressesTextarea.value.trim().split('\n').filter(addr => addr.trim() !== '');
      if (addressesToPaste.length > 0) {
        // Unconditionally clear all existing manual address fields
        manualAddressesList.innerHTML = ''; 

        addressesToPaste.forEach(addr => {
          addManualAddressField(addr);
        });
        pasteAddressesTextarea.value = ''; // Clear textarea
        setActiveTab(0); // Switch to Single Entry tab
        showMessage(`${addressesToPaste.length} addresses added to Single Entry.`, 'success');
      } else {
        showMessage('No addresses to paste.', 'warning');
      }
    });

    const excelFileInput = document.getElementById('excelFile');
    const messageArea = document.getElementById('messageArea');
    const addressListSection = document.getElementById('addressListSection');
    const debugArea = document.getElementById('debugArea');
    // const startAddressSelect = document.getElementById('startAddress');
    // const endAddressSelect = document.getElementById('endAddress');
    const middleAddressesList = document.getElementById('middleAddressesList');
    // Manual entry dynamic address fields
    const manualAddressesList = document.getElementById('manualAddressesList');
    const addManualAddressBtn = document.getElementById('addManualAddressBtn');

    // Make copyBtn and markVisitedBtn accessible globally
    let copyBtn = null;
    let markVisitedBtn = null;
    // Simple vertical stack for manual address fields
    function addManualAddressField(value = "") {
      const div = document.createElement('div');
      div.style.display = "flex";
      div.style.alignItems = "center";
      div.style.marginBottom = "6px";
      div.style.background = "none";
      div.style.border = "none";
      div.style.padding = "0";
      div.style.boxShadow = "none";
      div.style.gap = "4px";

      // Address input
      const input = document.createElement('input');
      input.type = "text";
      input.placeholder = "Address";
      input.value = value;
      input.style.flex = "1 1 0";
      input.style.minWidth = "0";
      input.style.marginRight = "4px";
      input.style.padding = "8px 10px";
      input.style.fontSize = "0.97rem";
      input.style.borderRadius = "6px";
      input.style.border = "1.2px solid #b3c6e6";
      input.required = true;

      // Remove button - Small red X
      const removeBtn = document.createElement('button');
      removeBtn.type = "button";
      removeBtn.textContent = "âœ•";
      removeBtn.title = "Remove";
      removeBtn.classList.add('remove-address-btn');
      removeBtn.style.marginLeft = '8px'; // Space from input
      removeBtn.onclick = () => div.remove();

      div.appendChild(input);
      div.appendChild(removeBtn);
      manualAddressesList.appendChild(div);
    }
    addManualAddressBtn.onclick = () => addManualAddressField();
    // Add one address field by default
    addManualAddressField();

    // Helper to set required only if manual entry section is visible
    function updateManualAddressRequired() {
      const singleEntryContentVisible = singleEntryContent && singleEntryContent.style.display !== 'none';
      const manualInputs = document.querySelectorAll('#manualAddressesList input[type="text"]');
      manualInputs.forEach(i => i.required = !!singleEntryContentVisible);

      // Also handle required for customStartAddress in the Upload File tab
      const uploadFileContentVisible = uploadFileContent && uploadFileContent.style.display !== 'none';
      const customStartAddressInput = document.getElementById('customStartAddress');
      if (customStartAddressInput) {
        customStartAddressInput.required = !!uploadFileContentVisible && excelFileInput.files.length > 0;
      }
    }
    // Call on page load and whenever manual section is shown/hidden
    window.addEventListener('DOMContentLoaded', () => {
        setActiveTab(0); // Set initial active tab
        updateManualAddressRequired();
    });
    // Also call after adding/removing fields
    manualAddressesList.addEventListener('DOMNodeInserted', updateManualAddressRequired);
    manualAddressesList.addEventListener('DOMNodeRemoved', updateManualAddressRequired);

    const addressesTextarea = null;
    const manualEntryLabel = null;
    const filterSection = document.getElementById('filterSection');
    const auctionDateFilterSelect = document.getElementById('auctionDateFilter');
    markVisitedBtn = document.getElementById('markVisitedBtn');

    let allExcelItems = []; // Holds all successfully parsed items from Excel
    let currentlyDisplayedItems = []; // Holds items after filtering, used for UI population

    function formatDate(rawDateValue) {
      if (rawDateValue === null || rawDateValue === undefined || String(rawDateValue).trim() === "") return null;
      let date;
      if (typeof rawDateValue === 'number') {
        const excelEpoch = new Date(1899, 11, 30);
        date = new Date(excelEpoch.getTime() + rawDateValue * 24 * 60 * 60 * 1000);
        if (rawDateValue < 60) date.setDate(date.getDate() - 1);
      } else if (rawDateValue instanceof Date) {
        date = rawDateValue;
      } else if (typeof rawDateValue === 'string') {
        date = new Date(rawDateValue);
        if (isNaN(date.getTime())) {
          const parts = rawDateValue.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
          if (parts) {
            let year = parseInt(parts[3], 10);
            if (year < 100) year += (year < 50 ? 2000 : 1900);
            let d1 = new Date(year, parseInt(parts[1], 10) - 1, parseInt(parts[2], 10));
            let d2 = new Date(year, parseInt(parts[2], 10) - 1, parseInt(parts[1], 10));
            if (!isNaN(d1.getTime()) && d1.getMonth() === (parseInt(parts[1], 10) - 1)) date = d1;
            else if (!isNaN(d2.getTime()) && d2.getMonth() === (parseInt(parts[2], 10) - 1)) date = d2;
            else date = null;
          } else date = null;
        }
      }
      if (date && !isNaN(date.getTime())) {
        return `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}/${date.getFullYear()}`;
      }
      return typeof rawDateValue === 'string' ? rawDateValue : null;
    }

function showMessage(msg, type = "info") {
  const messageArea = document.getElementById('messageArea');
  if (!messageArea) return;
  messageArea.innerHTML = msg;
  messageArea.style.display = 'block';
  messageArea.style.background = type === 'success'
    ? '#e6f9ec'
    : type === 'error'
    ? '#ffeaea'
    : type === 'warning'
    ? '#fffbe7'
    : '#eaf1fb';
  messageArea.style.color = type === 'success'
    ? '#217a3c'
    : type === 'error'
    ? '#b30000'
    : type === 'warning'
    ? '#7a5d00'
    : '#1a355b';
  messageArea.style.border = type === 'success'
    ? '1.5px solid #6ee7b7'
    : type === 'error'
    ? '1.5px solid #ffb3b3'
    : type === 'warning'
    ? '1.5px solid #ffe082'
    : '1.5px solid #b3c6e6';
}
function hideMessage() { /* ... (implementation unchanged) ... */ }
    function showDebug(headers, rows) { /* ... (implementation unchanged) ... */ }
    function hideDebug() { /* ... (implementation unchanged) ... */ }

    // --- Google Sheets Integration ---
    document.addEventListener('DOMContentLoaded', function() {
      const loadBtn = document.getElementById('loadGoogleSheetBtn');
      const urlInput = document.getElementById('googleSheetUrl');
      const errorDiv = document.getElementById('googleSheetError');
      if (loadBtn && urlInput) {
        loadBtn.addEventListener('click', async function() {
          errorDiv.style.display = 'none';
          errorDiv.textContent = '';
          const url = urlInput.value.trim();
          const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
          if (!match) {
            errorDiv.textContent = 'Invalid Google Sheets URL.';
            errorDiv.style.display = 'block';
            return;
          }
          const sheetId = match[1];
          // Use the backend proxy endpoint for the first sheet
          const csvUrl = `https://googlemaps-fastest-route-1.onrender.com/fetch-google-sheet-csv?sheetId=${sheetId}`;
          try {
            const resp = await fetch(csvUrl);
            if (!resp.ok) throw new Error('Could not fetch Google Sheet. Make sure it is shared as "Anyone with the link can view".');
            const csvText = await resp.text();
            // Parse CSV using XLSX
            const workbook = XLSX.read(csvText, { type: "string" });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, dateNF: 'MM/DD/YYYY' });
            if (!rows.length) throw new Error('No data found in Google Sheet.');
            // Simulate Excel upload flow
            let firstDataRow = 0;
            while (firstDataRow < rows.length && rows[firstDataRow].every(cell => !cell || String(cell).trim() === "")) firstDataRow++;
            if (firstDataRow >= rows.length) throw new Error('No header row found.');
            const headers = rows[firstDataRow].map(h => String(h || "EmptyHeader").trim());
            const dataRows = rows.slice(firstDataRow + 1).filter(row => row.some(cell => cell && String(cell).trim() !== ""));
            // Patch: Normalize "Foreclosure date" to "Auction Date" for compatibility
            const normalizedHeaders = headers.map(h => h.toLowerCase().includes('foreclosure') ? 'Auction Date' : h);

            // Show the column mapping prompt (reuse Excel logic)
            let addressFieldPrompt = document.getElementById('addressFieldPrompt');
            if (!addressFieldPrompt) {
              addressFieldPrompt = document.createElement('div');
              addressFieldPrompt.id = 'addressFieldPrompt';
              addressFieldPrompt.style = 'margin:16px 0;padding:12px;background:#fffbe7;border:1.5px solid #ffe082;border-radius:8px;';
              addressFieldPrompt.style.display = 'block';
              filterSection.parentNode.insertBefore(addressFieldPrompt, filterSection);
            } else {
              addressFieldPrompt.style.display = 'block';
            }
            let preset = null; try { preset = JSON.parse(localStorage.getItem('addressColPreset') || 'null'); } catch {}
            addressFieldPrompt.innerHTML = `
              <b>Select columns:</b><br>
              <label>Address: <select id="addressColSelect">${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
              <label>City (opt): <select id="cityColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
              <label>State (opt): <select id="stateColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label><br>
              <label>First Name (opt): <select id="firstNameColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
              <label>Last Name (opt): <select id="lastNameColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label><br>
              <label>Auction Date (opt): <select id="auctionDateColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
              <div style="margin-top: 16px;">
                <button type="button" id="confirmAddressCols" class="material-button material-button-contained">Confirm</button> 
                <button type="button" id="clearPreset" class="material-button material-button-text" style="margin-left: 8px;">Clear Preset</button>
              </div>
            `;
            if (preset && Array.isArray(preset) && preset.length === 6) { // Now 6 values
              document.getElementById('addressColSelect').value = preset[0];
              if(preset[1] !== null) document.getElementById('cityColSelect').value = preset[1];
              if(preset[2] !== null) document.getElementById('stateColSelect').value = preset[2];
              if(preset[3] !== null) document.getElementById('firstNameColSelect').value = preset[3];
              if(preset[4] !== null) document.getElementById('lastNameColSelect').value = preset[4];
              if(preset[5] !== null) document.getElementById('auctionDateColSelect').value = preset[5];
            }
            document.getElementById('confirmAddressCols').onclick = function() {
              try {
                // Read all select values first, with null checks
                const addressColSelect = document.getElementById('addressColSelect');
                const cityColSelect = document.getElementById('cityColSelect');
                const stateColSelect = document.getElementById('stateColSelect');
                const firstNameColSelect = document.getElementById('firstNameColSelect');
                const lastNameColSelect = document.getElementById('lastNameColSelect');
                const auctionDateColSelect = document.getElementById('auctionDateColSelect');

                if (!addressColSelect) throw new Error("Address column select not found.");

                const addrIdx = parseInt(addressColSelect.value, 10);
                const cityIdx = cityColSelect && cityColSelect.value !== "" ? parseInt(cityColSelect.value, 10) : null;
                const stateIdx = stateColSelect && stateColSelect.value !== "" ? parseInt(stateColSelect.value, 10) : null;
                const firstNameIdx = firstNameColSelect && firstNameColSelect.value !== "" ? parseInt(firstNameColSelect.value, 10) : null;
                const lastNameIdx = lastNameColSelect && lastNameColSelect.value !== "" ? parseInt(lastNameColSelect.value, 10) : null;
                const auctionDateIdx = auctionDateColSelect && auctionDateColSelect.value !== "" ? parseInt(auctionDateColSelect.value, 10) : null;

                // Now safe to remove the prompt
                if (addressFieldPrompt && addressFieldPrompt.parentNode) addressFieldPrompt.remove();

                localStorage.setItem('addressColPreset', JSON.stringify([addrIdx, cityIdx, stateIdx, firstNameIdx, lastNameIdx, auctionDateIdx]));

                const filteredRows = dataRows.filter(row => row[addrIdx] && String(row[addrIdx]).trim() !== "");
                const mappedItems = filteredRows.map(row => {
                  let fullAddress = String(row[addrIdx] || "").trim();
                  if (cityIdx !== null && row[cityIdx]) fullAddress += ', ' + String(row[cityIdx]).trim();
                  if (stateIdx !== null && row[stateIdx]) fullAddress += ', ' + String(row[stateIdx]).trim();
                  
                  let fullName = null;
                  const firstName = firstNameIdx !== null && row[firstNameIdx] ? String(row[firstNameIdx]).trim() : null;
                  const lastName = lastNameIdx !== null && row[lastNameIdx] ? String(row[lastNameIdx]).trim() : null;
                  if (firstName && lastName) fullName = `${firstName} ${lastName}`;
                  else if (firstName) fullName = firstName;
                  else if (lastName) fullName = lastName;

                  const rawDate = auctionDateIdx !== null && row[auctionDateIdx] ? row[auctionDateIdx] : null;
                  return {
                    address: fullAddress, name: fullName,
                    auctionDateRaw: rawDate, auctionDateFormatted: formatDate(rawDate),
                    lat: null, lng: null
                  };
                });
                allExcelItems = mappedItems.filter(item => item.address.length > 0);
                currentlyDisplayedItems = [...allExcelItems]; // Initially display all

                if (currentlyDisplayedItems.length < 1) { 
                  showMessage('No valid addresses found.', 'error'); return;
                }
                setTimeout(function() {
                  hideDebug();
                  populateAuctionDateFilter(currentlyDisplayedItems);
                  filterSection.style.display = '';
                  populateAddressSelection(currentlyDisplayedItems);
                  addressListSection.style.display = '';
                  showMessage('Addresses loaded from Google Sheets.', 'success');
                  if (currentlyDisplayedItems.length > 0) {
                    showMessage('Geocoding addresses...', 'info');
                    geocodeAddresses(currentlyDisplayedItems)
                      .then(geocodedItems => {
                        allExcelItems = geocodedItems;
                        currentlyDisplayedItems = [...allExcelItems];
                        applyAuctionDateMultiSelectFilter();
                      })
                      .catch(err => showMessage('Geocoding error: ' + err, 'error'));
                  }
                }, 0);
              } catch (err) { showMessage('Error processing columns: ' + err, 'error'); }
            };
            document.getElementById('clearPreset').onclick = () => { localStorage.removeItem('addressColPreset'); showMessage('Preset cleared.', 'info'); };
          } catch (err) {
            errorDiv.textContent = err.message;
            errorDiv.style.display = 'block';
          }
        });
      }
    });

    excelFileInput.addEventListener('change', function (e) {
      console.log('File input CHANGED');
      hideMessage(); hideDebug();
      const file = e.target.files[0]; if (!file) return;
      // When file input changes, ensure the Upload File tab is active
      // setActiveTab(2); // This might be too aggressive, consider user flow.
      // The existing logic inside excelFileInput.onchange should handle UI within its tab.
      updateManualAddressRequired();
      const reader = new FileReader();
      reader.onload = function (evt) {
        console.log('File reader ONLOAD');
        try {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: "array", cellDates: true }); // cellDates:true helps with date parsing
          if (!workbook.SheetNames || workbook.SheetNames.length === 0) { showMessage('No sheets found.', 'error'); return; }
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, dateNF: 'MM/DD/YYYY' }); // raw:false, dateNF for better date strings
          
          if (!rows.length) { showMessage('No data in sheet.', 'error'); return; }
          let firstDataRow = 0;
          while (firstDataRow < rows.length && rows[firstDataRow].every(cell => !cell || String(cell).trim() === "")) firstDataRow++;
          if (firstDataRow >= rows.length) { showMessage('No header row.', 'error'); return; }
          
          const headers = rows[firstDataRow].map(h => String(h || "EmptyHeader").trim());
          const dataRows = rows.slice(firstDataRow + 1).filter(row => row.some(cell => cell && String(cell).trim() !== ""));

          // Patch: Normalize "Foreclosure date" to "Auction Date" for compatibility
          const normalizedHeaders = headers.map(h => h.toLowerCase().includes('foreclosure') ? 'Auction Date' : h);
          // Use normalizedHeaders for dropdowns and mapping
          // (rest of the code below should use normalizedHeaders instead of headers)
          // This ensures the UI and logic will always find the date column

          let addressFieldPrompt = document.getElementById('addressFieldPrompt');
          if (!addressFieldPrompt) {
            addressFieldPrompt = document.createElement('div');
            addressFieldPrompt.id = 'addressFieldPrompt';
            addressFieldPrompt.style = 'margin:16px 0;padding:12px;background:#fffbe7;border:1.5px solid #ffe082;border-radius:8px;';
            // Ensure it's visible when created or re-created
            addressFieldPrompt.style.display = 'block'; 
            filterSection.parentNode.insertBefore(addressFieldPrompt, filterSection); 
            console.log('addressFieldPrompt created and inserted.');
          } else {
            addressFieldPrompt.style.display = 'block'; // Ensure it's visible if it already exists
            console.log('addressFieldPrompt already exists, ensuring it is visible.');
          }
          
          let preset = null; try { preset = JSON.parse(localStorage.getItem('addressColPreset') || 'null'); } catch {}
          console.log('Setting addressFieldPrompt.innerHTML');
          addressFieldPrompt.innerHTML = `
            <b>Select columns:</b><br>
            <label>Address: <select id="addressColSelect">${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <label>City (opt): <select id="cityColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <label>State (opt): <select id="stateColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label><br>
            <label>First Name (opt): <select id="firstNameColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <label>Last Name (opt): <select id="lastNameColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label><br>
            <label>Auction Date (opt): <select id="auctionDateColSelect"><option value="">(none)</option>${headers.map((h,i)=>`<option value="${i}">${h}</option>`)}</select></label>
            <div style="margin-top: 16px;">
              <button type="button" id="confirmAddressCols" class="material-button material-button-contained">Confirm</button> 
              <button type="button" id="clearPreset" class="material-button material-button-text" style="margin-left: 8px;">Clear Preset</button>
            </div>
          `;

          if (preset && Array.isArray(preset) && preset.length === 6) { // Now 6 values
            document.getElementById('addressColSelect').value = preset[0];
            if(preset[1] !== null) document.getElementById('cityColSelect').value = preset[1];
            if(preset[2] !== null) document.getElementById('stateColSelect').value = preset[2];
            if(preset[3] !== null) document.getElementById('firstNameColSelect').value = preset[3];
            if(preset[4] !== null) document.getElementById('lastNameColSelect').value = preset[4];
            if(preset[5] !== null) document.getElementById('auctionDateColSelect').value = preset[5];
          }

          document.getElementById('confirmAddressCols').onclick = function() {
            try {
              // Read all select values first, with null checks
              const addressColSelect = document.getElementById('addressColSelect');
              const cityColSelect = document.getElementById('cityColSelect');
              const stateColSelect = document.getElementById('stateColSelect');
              const firstNameColSelect = document.getElementById('firstNameColSelect');
              const lastNameColSelect = document.getElementById('lastNameColSelect');
              const auctionDateColSelect = document.getElementById('auctionDateColSelect');

              if (!addressColSelect) throw new Error("Address column select not found.");

              const addrIdx = parseInt(addressColSelect.value, 10);
              const cityIdx = cityColSelect && cityColSelect.value !== "" ? parseInt(cityColSelect.value, 10) : null;
              const stateIdx = stateColSelect && stateColSelect.value !== "" ? parseInt(stateColSelect.value, 10) : null;
              const firstNameIdx = firstNameColSelect && firstNameColSelect.value !== "" ? parseInt(firstNameColSelect.value, 10) : null;
              const lastNameIdx = lastNameColSelect && lastNameColSelect.value !== "" ? parseInt(lastNameColSelect.value, 10) : null;
              const auctionDateIdx = auctionDateColSelect && auctionDateColSelect.value !== "" ? parseInt(auctionDateColSelect.value, 10) : null;

              // Now safe to remove the prompt
              if (addressFieldPrompt && addressFieldPrompt.parentNode) addressFieldPrompt.remove();

              localStorage.setItem('addressColPreset', JSON.stringify([addrIdx, cityIdx, stateIdx, firstNameIdx, lastNameIdx, auctionDateIdx]));

              console.log('[DEBUG] dataRows.length:', dataRows.length);
              const filteredRows = dataRows.filter(row => row[addrIdx] && String(row[addrIdx]).trim() !== "");
              console.log('[DEBUG] After first filter, filteredRows.length:', filteredRows.length);
              const mappedItems = filteredRows.map(row => {
                let fullAddress = String(row[addrIdx] || "").trim();
                if (cityIdx !== null && row[cityIdx]) fullAddress += ', ' + String(row[cityIdx]).trim();
                if (stateIdx !== null && row[stateIdx]) fullAddress += ', ' + String(row[stateIdx]).trim();
                
                let fullName = null;
                const firstName = firstNameIdx !== null && row[firstNameIdx] ? String(row[firstNameIdx]).trim() : null;
                const lastName = lastNameIdx !== null && row[lastNameIdx] ? String(row[lastNameIdx]).trim() : null;
                if (firstName && lastName) fullName = `${firstName} ${lastName}`;
                else if (firstName) fullName = firstName;
                else if (lastName) fullName = lastName;

                const rawDate = auctionDateIdx !== null && row[auctionDateIdx] ? row[auctionDateIdx] : null;
                return {
                  address: fullAddress, name: fullName,
                  auctionDateRaw: rawDate, auctionDateFormatted: formatDate(rawDate),
                  lat: null, lng: null
                };
              });
              console.log('[DEBUG] After map, mappedItems.length:', mappedItems.length);
              allExcelItems = mappedItems.filter(item => item.address.length > 0);
              console.log('[DEBUG] After second filter, allExcelItems.length:', allExcelItems.length);

              currentlyDisplayedItems = [...allExcelItems]; // Initially display all

              if (currentlyDisplayedItems.length < 1) { 
                showMessage('No valid addresses found.', 'error'); return;
              }
              
              setTimeout(function() {
                console.log('[DEBUG] Inside setTimeout for UI display');
                hideDebug();
                populateAuctionDateFilter(currentlyDisplayedItems);
                filterSection.style.display = '';
                console.log('[DEBUG] filterSection.style.display set to blank. Computed:', getComputedStyle(filterSection).display, 'offsetHeight:', filterSection.offsetHeight);
                populateAddressSelection(currentlyDisplayedItems);
                addressListSection.style.display = '';
                console.log('[DEBUG] addressListSection.style.display set to blank. Computed:', getComputedStyle(addressListSection).display, 'offsetHeight:', addressListSection.offsetHeight);
                // if (addressesTextarea) addressesTextarea.required = false; // Not needed due to tabbing
                // if (manualEntryLabel) manualEntryLabel.style.display = 'none'; // Not needed
                showMessage('Addresses loaded.', 'success');

                if (currentlyDisplayedItems.length > 0) {
                  showMessage('Geocoding addresses...', 'info');
                  geocodeAddresses(currentlyDisplayedItems)
                    .then(geocodedItems => {
                      allExcelItems = geocodedItems; // Update allExcelItems with geocoded data
                      currentlyDisplayedItems = [...allExcelItems]; // Reset displayed to all (geocoded)
                      applyAuctionDateMultiSelectFilter(); // Re-apply filter if any, then update UI
                    })
                    .catch(err => showMessage('Geocoding error: ' + err, 'error'));
                }
              }, 0);
            } catch (err) { showMessage('Error processing columns: ' + err, 'error'); }
          };
          document.getElementById('clearPreset').onclick = () => { localStorage.removeItem('addressColPreset'); showMessage('Preset cleared.', 'info'); };
          // EXIT after setting up prompt and handlers so rest of function doesn't run
          return;
        } catch (err) { showMessage('Error parsing file: ' + err, 'error'); }
      };
      reader.readAsArrayBuffer(file);
    });

    // --- Multi-Select Dropdown Logic ---
    function populateAuctionDateFilter(items) {
      const dates = new Set();
      items.forEach(item => {
        if (item.auctionDateFormatted) dates.add(item.auctionDateFormatted);
      });
      const sortedDates = Array.from(dates).sort((a, b) => new Date(a) - new Date(b));
      const multiSelect = document.getElementById('auctionDateMultiSelect');
      if (!multiSelect) return;
      multiSelect.innerHTML = '';
      sortedDates.forEach(date => {
        const option = document.createElement('option');
        option.value = date;
        option.textContent = date;
        multiSelect.appendChild(option);
      });
    }

    function applyAuctionDateMultiSelectFilter() {
      const multiSelect = document.getElementById('auctionDateMultiSelect');
      const selected = Array.from(multiSelect.selectedOptions).map(opt => opt.value);
      if (selected.length === 0) {
        currentlyDisplayedItems = [...allExcelItems];
      } else {
        currentlyDisplayedItems = allExcelItems.filter(item => selected.includes(item.auctionDateFormatted));
      }
      populateAddressSelection(currentlyDisplayedItems);
      displayAddressMarkers(currentlyDisplayedItems);
    }

    document.addEventListener('DOMContentLoaded', function() {
      const multiSelect = document.getElementById('auctionDateMultiSelect');
      const selectAllBtn = document.getElementById('selectAllDatesBtn');
      const clearBtn = document.getElementById('clearDatesBtn');
      if (multiSelect) multiSelect.addEventListener('change', applyAuctionDateMultiSelectFilter);
      if (selectAllBtn) selectAllBtn.addEventListener('click', function() {
        Array.from(multiSelect.options).forEach(opt => opt.selected = true);
        applyAuctionDateMultiSelectFilter();
      });
      if (clearBtn) clearBtn.addEventListener('click', function() {
        Array.from(multiSelect.options).forEach(opt => opt.selected = false);
        applyAuctionDateMultiSelectFilter();
      });
    });
    
    function populateAddressSelection(itemsToDisplay) {
      console.log('[DEBUG] populateAddressSelection called. itemsToDisplay.length:', itemsToDisplay.length);
      updateMiddleAddresses(); // Only update middle addresses now
    }

    function updateMiddleAddresses() { // Operates on currentlyDisplayedItems
  const customStartAddressInput = document.getElementById('customStartAddress');
  const customEndAddressInput = document.getElementById('customEndAddress');
  const startAddr = customStartAddressInput ? customStartAddressInput.value.trim() : '';
  const endAddr = customEndAddressInput ? customEndAddressInput.value.trim() : '';

  // --- Preserve checked state ---
  const prevChecked = {};
  Array.from(middleAddressesList.querySelectorAll('input[type="checkbox"].address-checkbox')).forEach(cb => {
    prevChecked[cb.value] = cb.checked;
  });

  middleAddressesList.innerHTML = '';

  currentlyDisplayedItems.forEach(item => {
    const isVisited = item.visited === true;
    if (item.address !== startAddr && item.address !== endAddr) {
      const li = document.createElement('li');
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'address-checkbox';
      cb.value = item.address;
      cb.checked = !!prevChecked[item.address]; // Restore checked state if previously checked
      li.appendChild(cb);
      let dText = item.address;
      if (item.name) dText = `<b>${item.name}</b> - ${dText}`;
      if (item.auctionDateFormatted) dText += ` <span style="color:#0077b6;">(Auction: ${item.auctionDateFormatted})</span>`;
      const span = document.createElement('span');
      span.innerHTML = ' ' + dText;
      if (isVisited) {
        span.style.color = '#888';
        span.style.textDecoration = 'line-through';
      }
      li.appendChild(span);
      middleAddressesList.appendChild(li);
    }
  });
}
    // Update middle addresses when custom start/end address fields change
    // Save start address to localStorage on input and update middle addresses
    document.getElementById('customStartAddress').addEventListener('input', function(e) {
      localStorage.setItem('savedStartAddress', e.target.value.trim());
      updateMiddleAddresses();
    });
    // On page load, restore start address from localStorage if available
    window.addEventListener('DOMContentLoaded', function() {
      const saved = localStorage.getItem('savedStartAddress');
      if (saved) {
        document.getElementById('customStartAddress').value = saved;
      }
      updateMiddleAddresses();
    });
    document.getElementById('customEndAddress').addEventListener('input', updateMiddleAddresses);
    document.getElementById('routeForm').onsubmit = async function(e) {
      console.log('ROUTE FORM SUBMITTED');
      e.preventDefault();
      showMessage('Optimizing route...', 'info');
      let addresses = [];
      let startAddressForRoute = '';
      // let endAddressForRoute = ''; // Not explicitly used for constructing 'addresses' array in the new logic
      let waypointsForRoute = [];

      // Determine active tab
      const singleEntryActive = singleEntryContent.style.display === 'block';
      const uploadFileActive = uploadFileContent.style.display === 'block';
      // PasteList tab uses SingleEntry fields, so singleEntryActive check covers it.

      if (singleEntryActive) {
        console.log("Optimizing with Single Entry data");
        startAddressForRoute = document.getElementById('manualStartAddress').value.trim();
        const manualInputs = document.querySelectorAll('#manualAddressesList input[type="text"]');
        waypointsForRoute = Array.from(manualInputs).map(i => i.value.trim()).filter(a => a);

        if (startAddressForRoute) {
            addresses.push(startAddressForRoute); // Origin
            addresses = addresses.concat(waypointsForRoute); // Waypoints
            addresses.push(startAddressForRoute); // Destination (round trip)
        }
      } else if (uploadFileActive) {
        console.log("Optimizing with Upload File data");
        startAddressForRoute = document.getElementById('customStartAddress').value.trim();
        let endAddrFromFile = document.getElementById('customEndAddress').value.trim();
        const middleCheckboxes = document.querySelectorAll('#middleAddressesList input[type="checkbox"]:checked');
        waypointsForRoute = Array.from(middleCheckboxes).map(cb => cb.value);

        if (startAddressForRoute) {
            addresses.push(startAddressForRoute); // Origin
            addresses = addresses.concat(waypointsForRoute); // Waypoints
            if (endAddrFromFile && endAddrFromFile !== startAddressForRoute) {
                addresses.push(endAddrFromFile); // Explicit destination
            } else {
                addresses.push(startAddressForRoute); // Destination (round trip)
            }
        }
      }

      // Validate addresses collected
      // The backend needs at least an origin and a destination.
      // If waypointsForRoute is empty, addresses will be [origin, destination].
      // If addresses.length < 2, it means startAddressForRoute was likely empty.
      if (!startAddressForRoute) {
        let specificMessage = 'Please enter a Start Address.';
        if (singleEntryActive) specificMessage = 'Please enter a Start Address in the Single Entry tab.';
        else if (uploadFileActive) specificMessage = 'Please enter a Start Address in the Upload File tab (after loading a file and selecting columns).';
        showMessage(specificMessage, 'error');
        return;
      }
      
      // If start address is provided, but no waypoints, and it's a round trip (start=end)
      // the addresses array would be [start, start]. This is valid for the backend.
      // If there are waypoints, addresses will be [start, waypoint1, ..., end]
      // The critical check is if startAddressForRoute is present.
      // The backend will handle cases like only two identical points if that's an issue for routing.
      // Our primary validation here is that we have *some* start point.
      // A secondary validation could be if waypointsForRoute is empty AND (if singleEntryActive or no endAddrFromFile)
      // then it's just a start point to itself, which might not be what user wants.
      // However, the previous logic allowed this (e.g. startAddr + no middleAddrs + endAddr=startAddr).

      if (addresses.length < 2 && startAddressForRoute) { // Should not happen if logic above is correct for round trips
        showMessage('Please add at least one destination address, or ensure a round trip is formed.', 'error');
        return;
      }
      if (addresses.length === 0) { // Fallback if somehow no addresses were collected
        showMessage('No addresses were provided for optimization.', 'error');
        return;
      }


      console.log('Addresses for optimization:', JSON.stringify(addresses));

      try {
        const response = await fetch('https://googlemaps-fastest-route-1.onrender.com/optimize-route', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ addresses: addresses }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error', details: response.statusText }));
      throw new Error(`HTTP error ${response.status}: ${errorData.error} - ${JSON.stringify(errorData.details)}`);
    }

const result = await response.json();
console.log('Backend response received:', result);
console.log('Original addresses sent to backend:', addresses);

let optimizedFullRoute;
let optimizedCoordinates = [];
if (result.order && Array.isArray(result.order)) {
  const waypoints = addresses.slice(1, -1);
  optimizedFullRoute = [addresses[0]];
  result.order.forEach(idx => optimizedFullRoute.push(waypoints[idx]));
  optimizedFullRoute.push(addresses[addresses.length - 1]);

  console.log('Constructed optimizedFullRoute:', optimizedFullRoute);

}
    const waypoints = addresses.slice(1, -1);
    console.log('Waypoints extracted:', waypoints);
    console.log('Order from backend (result.order):', result.order);

    optimizedFullRoute = [addresses[0]];
    if (result.order && Array.isArray(result.order)) {
      result.order.forEach(idx => {
        console.log('Processing waypoint index from backend:', idx, 'Corresponding waypoint:', waypoints[idx]);
        optimizedFullRoute.push(waypoints[idx]);
      });
      optimizedFullRoute.push(addresses[addresses.length - 1]);
      console.log('Constructed optimizedFullRoute:', optimizedFullRoute);
      // Build Google Maps directions URL and open in new tab
      if (optimizedFullRoute.length >= 2) {
        const origin = encodeURIComponent(optimizedFullRoute[0]);
        const destination = encodeURIComponent(optimizedFullRoute[optimizedFullRoute.length - 1]);
        let waypointsString = "";
        if (optimizedFullRoute.length > 2) {
          waypointsString = optimizedFullRoute.slice(1, -1).map(addr => encodeURIComponent(addr)).join('|');
        }
        let googleMapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}`;
        if (waypointsString) {
          googleMapsUrl += `&waypoints=${waypointsString}`;
        }
        googleMapsUrl += `&travelmode=driving`;
        window.open(googleMapsUrl, '_blank');
        showMessage('Optimized route opened in Google Maps.<br>Order:<br>' + optimizedFullRoute.join('<br>'), 'success');
      } else {
        showMessage('Not enough addresses to generate a Google Maps link.', 'error');
      }
    } else {
      console.error('Error: result.order is not a valid array!', result.order);
      showMessage('Error processing backend response: Invalid route order.', 'error');
    }
    // Optionally, update the map here to show the optimized route.
  } catch (error) {
    console.error('Optimization error:', error);
    showMessage('Failed to optimize route: ' + error.message, 'error');
  }
};
    excelFileInput.addEventListener('click', function(e) { /* ... (implementation as before, reset allExcelItems and currentlyDisplayedItems) ... */ });
    
    // ... (rest of the script: initializeBasicMap, geocodeAddresses, displayAddressMarkers, Leaflet draw events) ...
    // Ensure geocodeAddresses and displayAddressMarkers use the passed items (currentlyDisplayedItems)
    // Ensure Leaflet draw event CREATED uses currentlyDisplayedItems for checking markers
    // Ensure populateAddressSelection, updateMiddleAddresses use the correct item list (currentlyDisplayedItems)

    // Re-pasting the functions that need to be aware of currentlyDisplayedItems or allExcelItems
    // (Many were already correct or handled by passing the list as an argument)

    
    // Ensure excelFileInput click resets all relevant lists
    // Fix: Always trigger 'change' event if the same file is uploaded again
    excelFileInput.addEventListener('click', function(e) {
      excelFileInput.value = null; // Reset file input so 'change' always fires
      console.log(`File input CLICKED (${new Date().toISOString()}) - resetting UI and data.`);
      allExcelItems = [];
      currentlyDisplayedItems = [];
      excelAddresses = []; 
      addressListSection.style.display = 'none';
      filterSection.style.display = 'none';
      auctionDateFilterSelect.innerHTML = '<option value="all">All Dates</option>';
      updateManualAddressRequired();
      hideMessage();
      hideDebug();
    });


    // MAP AND DRAWING LOGIC (ensure it uses currentlyDisplayedItems for context if needed)
    let map;
    let drawnItems;
    let drawControl; // Make drawControl accessible globally
    function initializeBasicMap() {
      console.log("initializeBasicMap: Starting");
      try {
        map = L.map('map').setView([29.7604, -95.3698], 10);
        console.log("initializeBasicMap: L.map created");

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        console.log("initializeBasicMap: TileLayer added");

        drawnItems = new L.FeatureGroup();
        console.log("initializeBasicMap: FeatureGroup created");
        map.addLayer(drawnItems);
        console.log("initializeBasicMap: FeatureGroup added to map");

        drawControl = new L.Control.Draw({
          edit: false,
          draw: {
            polygon: true,
            polyline: false,
            rectangle: true,
            circle: false,
            marker: false,
            circlemarker: false
          }
        });
        console.log("initializeBasicMap: DrawControl options defined");
        map.addControl(drawControl);
        console.log("initializeBasicMap: DrawControl added to map");
      } catch (error) {
        console.error("initializeBasicMap: ERROR during initialization!", error);
      }
      console.log("initializeBasicMap: Finished (or error caught)");
    }
    console.log("About to initialize map...");
    initializeBasicMap();

    async function geocodeAddresses(itemsArray) { /* ... (as previously corrected, operates on itemsArray) ... */ 
        const apiKey = "AIzaSyAq-_o7JolKDWy943Q-dejkoqzPvJKIV2k"; 
        const cache = JSON.parse(localStorage.getItem("geocodeCache") || "{}");
        for (const item of itemsArray) {
            if (typeof item.lat === 'number' && typeof item.lng === 'number' && item.lat !== null && item.lng !== null) continue;
            const addressToGeocode = item.address;
            if (cache[addressToGeocode]) {
                item.lat = cache[addressToGeocode].lat; item.lng = cache[addressToGeocode].lng; continue;
            }
            const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(addressToGeocode)}&key=${apiKey}`;
            try {
                const resp = await fetch(url); const data = await resp.json();
                if (data.status === "OK" && data.results && data.results[0]) {
                    const loc = data.results[0].geometry.location;
                    item.lat = loc.lat; item.lng = loc.lng;
                    cache[addressToGeocode] = { lat: loc.lat, lng: loc.lng };
                } else { item.lat = null; item.lng = null; console.warn('Failed geocode:', addressToGeocode, data.status); }
            } catch (err) { item.lat = null; item.lng = null; console.error('Fetch error geocoding:', addressToGeocode, err); }
            await new Promise(res => setTimeout(res, 60));
        }
        localStorage.setItem("geocodeCache", JSON.stringify(cache));
        return itemsArray; 
    }

    let addressMarkersLayer = null;
    function displayAddressMarkers(itemsToDisplayOnMap) { /* ... (as previously corrected, uses itemsToDisplayOnMap) ... */
        if (!map) return;
        if (addressMarkersLayer) map.removeLayer(addressMarkersLayer);
        const markers = []; let plottedCount = 0;
        itemsToDisplayOnMap.forEach(item => {
            if (item && typeof item.lat === 'number' && typeof item.lng === 'number') {
                const marker = L.marker([item.lat, item.lng]);
                let popupHtml = `<strong>${item.address}</strong>`;
                if (item.name) popupHtml = `<strong>${item.name}</strong><br>${item.address}`;
                if (item.auctionDateFormatted) popupHtml += `<br><span style="color:#0077b6;">Auction: ${item.auctionDateFormatted})</span>`;
                marker.bindPopup(popupHtml);
                marker.customData = item; 
                markers.push(marker); plottedCount++;
            }
        });
        if (plottedCount > 0) {
            addressMarkersLayer = L.layerGroup(markers).addTo(map);
            const notPlotted = itemsToDisplayOnMap.length - plottedCount;
            showMessage(`${plottedCount} plotted. ${notPlotted > 0 ? notPlotted + ' not geocoded.' : ''}`, notPlotted > 0 ? 'warning' : 'success');
        } else showMessage('No coordinates to plot.', 'warning');
    }

    if (window.L && map) {
      // --- Show onboarding tooltip for draw button on first load ---
      window.addEventListener('DOMContentLoaded', function() {
        try {
          if (!localStorage.getItem('drawButtonTooltipShown')) {
            setTimeout(function() {
              // Try to find the draw button (rectangle icon) and highlight it
              const leafletControls = document.querySelectorAll('.leaflet-draw-toolbar .leaflet-draw-draw-rectangle');
              if (leafletControls.length > 0) {
                leafletControls[0].style.boxShadow = '0 0 0 4px #ffe082, 0 0 12px #7a5d00';
                leafletControls[0].style.transition = 'box-shadow 0.5s';
                leafletControls[0].setAttribute('title', 'Draw a shape to select addresses');
                document.getElementById('drawTooltip').style.display = 'inline-block';

                // Position an arrow overlay pointing to the button
                const btnRect = leafletControls[0].getBoundingClientRect();
                const mapRect = document.getElementById('map').getBoundingClientRect();
                const overlay = document.getElementById('drawArrowOverlay');
                // Calculate arrow start (right of button) and end (left of button)
                const arrowStartX = btnRect.right - mapRect.left + 10;
                const arrowStartY = btnRect.top - mapRect.top + btnRect.height / 2;
                const arrowEndX = btnRect.left - mapRect.left - 30;
                const arrowEndY = arrowStartY + 10;
                overlay.innerHTML = `<svg width="120" height="60" style="overflow:visible;">
                  <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#7a5d00"/>
                    </marker>
                  </defs>
                  <line x1="100" y1="30" x2="10" y2="40" stroke="#7a5d00" stroke-width="4" marker-end="url(#arrowhead)" />
                </svg>`;
                overlay.style.display = 'block';
                overlay.style.left = (btnRect.right - mapRect.left + 10) + 'px';
                overlay.style.top = (btnRect.top - mapRect.top - 10) + 'px';
                overlay.style.width = '120px';
                overlay.style.height = '60px';

                setTimeout(function() {
                  leafletControls[0].style.boxShadow = '';
                  document.getElementById('drawTooltip').style.display = 'none';
                  overlay.style.display = 'none';
                  localStorage.setItem('drawButtonTooltipShown', '1');
                }, 6000);
              }
            }, 1200); // Wait for map controls to render
          }
        } catch (e) {}
      });
      // --- Custom Clear All Button Control ---
      L.Control.ClearButton = L.Control.extend({
        options: { position: 'topleft' },
        onAdd: function(map) {
          // Create a button styled like Leaflet.draw tools
          const container = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');
          const btn = L.DomUtil.create('a', 'leaflet-draw-toolbar-button leaflet-draw-clear-all', container);
          btn.id = 'clearAllMapSelections';
          btn.href = '#';
          btn.title = 'Clear all drawn shapes and selections';
          btn.setAttribute('role', 'button');
          btn.setAttribute('aria-label', 'Clear all drawn shapes and selections');
          // Use text "CLEAR" instead of icon
          btn.innerHTML = '<span style="font-weight:700;font-size:1.08em;letter-spacing:1px;">CLEAR</span>';
          btn.style.width = '48px';
          btn.style.height = '34px';
          btn.style.background = '#fff';
          btn.style.border = 'none';
          btn.style.marginTop = '6px';
          btn.style.display = 'flex';
          btn.style.alignItems = 'center';
          btn.style.justifyContent = 'center';
          btn.style.boxShadow = '0 1px 4px rgba(44,62,80,0.08)';
          btn.style.cursor = 'pointer';
          btn.onmouseover = function() { btn.style.background = '#f4f6fa'; };
          btn.onmouseout = function() { btn.style.background = '#fff'; };
          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);
          btn.onclick = function(e) {
            e.preventDefault();
            handleClearSelections();
            showMessage('Selections and drawn shapes cleared.', 'info');
          };
          return container;
        },
        onRemove: function(map) {}
      });
      L.control.clearButton = function(opts) {
        return new L.Control.ClearButton(opts);
      };
      L.control.clearButton({ position: 'topleft' }).addTo(map);

      // --- Centralized clear logic ---
      function handleClearSelections() {
        if (drawnItems) {
          drawnItems.clearLayers();
        }
        if (typeof copyBtn !== "undefined" && copyBtn) copyBtn.style.display = 'none';
        populateAddressSelection(currentlyDisplayedItems);
        console.log("handleClearSelections: Selections cleared and address list repopulated.");
      }

      // Restore default draw control behavior (no duplicate controls)
      map.on(L.Draw.Event.CREATED, function (event) {
        drawnItems.clearLayers();
        const drawnLayer = event.layer;
        drawnItems.addLayer(drawnLayer);

        // Explicitly disable drawing mode after drawing (rectangle or polygon)
        if (
          drawControl &&
          drawControl._toolbars &&
          drawControl._toolbars.draw &&
          drawControl._toolbars.draw._modes
        ) {
          if (
            event.layerType === 'rectangle' &&
            drawControl._toolbars.draw._modes.rectangle &&
            drawControl._toolbars.draw._modes.rectangle.handler
          ) {
            drawControl._toolbars.draw._modes.rectangle.handler.disable();
          }
          if (
            event.layerType === 'polygon' &&
            drawControl._toolbars.draw._modes.polygon &&
            drawControl._toolbars.draw._modes.polygon.handler
          ) {
            drawControl._toolbars.draw._modes.polygon.handler.disable();
          }
        }

        const selectedItemsInShape = [];

        if (addressMarkersLayer) {
          addressMarkersLayer.eachLayer(function (marker) {
            if (marker.customData) {
              const markerLatLng = marker.getLatLng();
              let isInside = false;
              if (drawnLayer instanceof L.Circle) isInside = markerLatLng.distanceTo(drawnLayer.getLatLng()) <= drawnLayer.getRadius();
              else if (drawnLayer.getBounds) isInside = drawnLayer.getBounds().contains(markerLatLng);

              if (isInside) {
                selectedItemsInShape.push(marker.customData);
              }
            }
          });
        }

        const middleAddressesListUI = document.getElementById('middleAddressesList');
        if (middleAddressesListUI) {
          middleAddressesListUI.innerHTML = '';
          selectedItemsInShape.forEach(item => {
            const li = document.createElement('li');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.className = 'address-checkbox';
            checkbox.value = item.address; checkbox.checked = true;
            li.appendChild(checkbox);
            let dText = item.address;
            if (item.name) dText = `<b>${item.name}</b> - ${dText}`;
            if (item.auctionDateFormatted) dText += ` <span style="color:#0077b6;">(Auction: ${item.auctionDateFormatted})</span>`;
            const span = document.createElement('span'); span.innerHTML = ' ' + dText;
            li.appendChild(span);
            middleAddressesListUI.appendChild(li);
          });
        }
        if (typeof copyBtn !== "undefined" && copyBtn) copyBtn.style.display = selectedItemsInShape.length > 0 ? 'block' : 'none';
        if (typeof markVisitedBtn !== "undefined" && markVisitedBtn) markVisitedBtn.style.display = selectedItemsInShape.length > 0 ? 'block' : 'none';
        if (selectedItemsInShape.length > 0) {
          showMessage(`${selectedItemsInShape.length} addresses selected.`, 'success');
        }
      });

      // Remove any map click handler that clears drawn shapes (if present)
      // Only clear shapes when user clicks the CLEAR button or deletes the shape
      map.on('draw:deleted', function() {
        handleClearSelections();
        if (markVisitedBtn) markVisitedBtn.style.display = 'none';
        showMessage('Drawn shapes deleted and selections cleared.', 'info');
      });

      // Copy Selected Addresses button logic
document.addEventListener('DOMContentLoaded', function() {
    copyBtn = document.getElementById('copySelectedBtn');
    markVisitedBtn = document.getElementById('markVisitedBtn');

    if (markVisitedBtn) {
        markVisitedBtn.addEventListener('click', function() {
            const listItems = middleAddressesList.getElementsByTagName('li');
            for (let item of listItems) {
                const checkbox = item.querySelector('input[type="checkbox"]');
                const span = item.querySelector('span');
                if (checkbox && checkbox.checked && span) {
                    const address = checkbox.value;
                    const matchedItem = allExcelItems.find(i => i.address === address);
                    if (matchedItem) {
                        matchedItem.visited = true;
                        span.style.color = '#888';
                        span.style.textDecoration = 'line-through';
                    }
                }
            }
            showMessage('Selected addresses marked as visited.', 'success');
        });
    }

    if (copyBtn) {
        copyBtn.addEventListener('click', function() {
            const addressesToCopy = [];
            const listItems = middleAddressesList.getElementsByTagName('li');
            for (let item of listItems) {
                const checkbox = item.querySelector('input[type="checkbox"]');
                if (checkbox && checkbox.checked) {
                    addressesToCopy.push(checkbox.value);
                }
            }
            if (addressesToCopy.length > 0) {
                navigator.clipboard.writeText(addressesToCopy.join('\n'))
                    .then(() => showMessage('Selected addresses copied to clipboard!', 'success'))
                    .catch(err => showMessage('Failed to copy addresses: ' + err, 'error'));
            } else {
                showMessage('No addresses to copy.', 'info');
            }
        });
    }
});
    }
  </script>
  <script>
    // --- FirebaseUI Auth Integration ---
    document.addEventListener('DOMContentLoaded', function() {
      // FirebaseUI config
      var uiConfig = {
        signInFlow: "popup",
        signInOptions: [
          firebase.auth.GoogleAuthProvider.PROVIDER_ID,
          firebase.auth.EmailAuthProvider.PROVIDER_ID
        ],
        credentialHelper: firebaseui.auth.CredentialHelper.NONE,
        callbacks: {
          signInSuccessWithAuthResult: function(authResult, redirectUrl) {
            // Hide login card after successful login
            var authCard = document.getElementById('firebaseui-auth-card');
            if (authCard) authCard.style.display = 'none';
            return false;
          }
        }
      };

      // Initialize the FirebaseUI Widget using Firebase.
      var ui = firebaseui.auth.AuthUI.getInstance() || new firebaseui.auth.AuthUI(firebase.auth());

      // Elements
      var authCard = document.getElementById('firebaseui-auth-card');
      var authContainer = document.getElementById('firebaseui-auth-container');
      var showLoginBtn = document.getElementById('show-login-btn');
      var closeLoginBtn = document.getElementById('close-login-btn');
      var userInfo = document.getElementById('user-info');
      var userEmail = document.getElementById('user-email');
      var logoutBtn = document.getElementById('logout-btn');

      // Show login card on button click
      if (showLoginBtn) {
        showLoginBtn.addEventListener('click', function() {
          if (authCard) {
            authCard.style.display = 'block';
            if (authContainer) ui.start('#firebaseui-auth-container', uiConfig);
          }
        });
      }
      // Hide login card on cancel
      if (closeLoginBtn) {
        closeLoginBtn.addEventListener('click', function() {
          if (authCard) authCard.style.display = 'none';
        });
      }

      // Listen for auth state changes
      firebase.auth().onAuthStateChanged(function(user) {
        // Always hide login card on state change
        if (authCard) authCard.style.display = 'none';
        if (user) {
          // User is signed in
          if (showLoginBtn) showLoginBtn.style.display = 'none';
          if (userInfo) {
            userInfo.style.display = 'inline-block';
            if (userEmail) userEmail.textContent = user.email || '';
          }
        } else {
          // User is signed out
          if (showLoginBtn) showLoginBtn.style.display = 'inline-block';
          if (userInfo) userInfo.style.display = 'none';
        }
      });

      // Logout button handler
      if (logoutBtn) {
        logoutBtn.addEventListener('click', function() {
          firebase.auth().signOut();
        });
      }
    });
  </script>
</body>
</html>

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.

<environment_details>
# VSCode Visible Files
index.html
index.html
index.html

# VSCode Open Tabs
inspect-excel.js
.git/COMMIT_EDITMSG
indexclaude.html
index.html
optimize-backend.js

# Current Time
6/3/2025, 12:47:03 PM (America/Chicago, UTC-5:00)

# Context Window Usage
336,102 / 1,048.576K tokens used (32%)

# Current Mode
ACT MODE
</environment_details>
